 (** [iter2 f a b] applies function [f] to all the elements of [a]
    and [b].
    @raise Invalid_argument if the arrays are not the same size.
-   @since 4.03 (4.05 in ArrayLabels)
+   @since 4.05
    *)

 val map2 : ('a -> 'b -> 'c) -> 'a array -> 'b array -> 'c array
    and [b], and builds an array with the results returned by [f]:
    [[| f a.(0) b.(0); ...; f a.(length a - 1) b.(length b - 1)|]].
    @raise Invalid_argument if the arrays are not the same size.
-   @since 4.03 (4.05 in ArrayLabels) *)
+   @since 4.05 *)


 (** {1 Array scanning} *)

     For example, consider the following program:
 {[let size = 100_000_000
-let a = Array.make size 1
+let a = ArrayLabels.make size 1
 let d1 = Domain.spawn (fun () ->
-   Array.iteri (fun i x -> a.(i) <- x + 1) a
+   ArrayLabels.iteri f:(fun i x -> a.(i) <- x + 1) a
 )
 let d2 = Domain.spawn (fun () ->
-  Array.iteri (fun i x -> a.(i) <- 2 * x + 1) a
+  ArrayLabels.iteri f:(fun i x -> a.(i) <- 2 * x + 1) a
 )
 let () = Domain.join d1; Domain.join d2
 ]}
     the corresponding side of [s].
     @raise Invalid_argument if the result length is negative or
     longer than {!Sys.max_string_length} bytes.
-    @since 4.05 in BytesLabels *)
+    @since 4.05 *)

 val fill : bytes -> int -> int -> char -> unit
 (** [fill s pos len c] modifies [s] in place, replacing [len]
     @raise Invalid_argument if [src_pos] and [len] do not
     designate a valid range of [src], or if [dst_pos] and [len]
     do not designate a valid range of [dst].
-    @since 4.05 in BytesLabels *)
+    @since 4.05 *)

 val concat : bytes -> bytes list -> bytes
 (** [concat sep sl] concatenates the list of byte sequences [sl],
     as a new byte sequence.
     @raise Invalid_argument if the result is longer than
     {!Sys.max_string_length} bytes.
-    @since 4.05 in BytesLabels *)
+    @since 4.05 *)

 val iter : (char -> unit) -> bytes -> unit
 (** [iter f s] applies function [f] in turn to all the bytes of [s].
 val uppercase_ascii : bytes -> bytes
 (** Return a copy of the argument, with all lowercase letters
    translated to uppercase, using the US-ASCII character set.
-   @since 4.03 (4.05 in BytesLabels) *)
+   @since 4.05 *)

 val lowercase_ascii : bytes -> bytes
 (** Return a copy of the argument, with all uppercase letters
    translated to lowercase, using the US-ASCII character set.
-   @since 4.03 (4.05 in BytesLabels) *)
+   @since 4.05 *)

 val capitalize_ascii : bytes -> bytes
 (** Return a copy of the argument, with the first character set to uppercase,
    using the US-ASCII character set.
-   @since 4.03 (4.05 in BytesLabels) *)
+   @since 4.05 *)

 val uncapitalize_ascii : bytes -> bytes
 (** Return a copy of the argument, with the first character set to lowercase,
    using the US-ASCII character set.
-   @since 4.03 (4.05 in BytesLabels) *)
+   @since 4.05 *)

 type t = bytes
 (** An alias for the type of byte sequences. *)

 val equal: t -> t -> bool
 (** The equality function for byte sequences.
-    @since 4.03 (4.05 in BytesLabels) *)
+    @since 4.05 *)

-val starts_with : prefix:bytes -> bytes -> bool
-(** [starts_with ~prefix s] is [true] if and only if [s] starts with
+val starts_with : bytes -> bytes -> bool
+(** [starts_with prefix s] is [true] if and only if [s] starts with
     [prefix].

     @since 4.13 *)

-val ends_with : suffix:bytes -> bytes -> bool
-(** [ends_with ~suffix s] is [true] if and only if [s] ends with [suffix].
+val ends_with : bytes -> bytes -> bool
+(** [ends_with suffix s] is [true] if and only if [s] ends with [suffix].

     @since 4.13 *)


 val cons : 'a -> 'a list -> 'a list
 (** [cons x xs] is [x :: xs]
-    @since 4.03 (4.05 in ListLabels)
+    @since 4.05
  *)

 val hd : 'a list -> 'a

 val sort_uniq : ('a -> 'a -> int) -> 'a list -> 'a list
 (** Same as {!sort}, but also remove duplicates.
-    @since 4.02 (4.03 in ListLabels)
+    @since 4.03
  *)

 val merge : ('a -> 'a -> int) -> 'a list -> 'a list -> 'a list
 val equal : t -> t -> bool
 (** [equal s0 s1] is [true] if and only if [s0] and [s1] are character-wise
     equal.
-    @since 4.03 (4.05 in StringLabels) *)
+    @since 4.05 *)

 val compare : t -> t -> int
 (** [compare s0 s1] sorts [s0] and [s1] in lexicographical order. [compare]
     behaves like {!Stdlib.compare} on strings but may be more efficient. *)

-val starts_with : prefix:string -> string -> bool
-(** [starts_with ~prefix s] is [true] if and only if [s] starts with [prefix].
+val starts_with : string -> string -> bool
+(** [starts_with prefix s] is [true] if and only if [s] starts with [prefix].

     @since 4.13 *)

-val ends_with : suffix:string -> string -> bool
-(** [ends_with ~suffix s] is [true] if and only if [s] ends with [suffix].
+val ends_with : string -> string -> bool
+(** [ends_with suffix s] is [true] if and only if [s] ends with [suffix].

     @since 4.13 *)

       (split_on_char sep s) = s]).}
     {- No string in the result contains the [sep] character.}}

-    @since 4.04 (4.05 in StringLabels) *)
+    @since 4.05 *)

 (** {1:transforming Transforming} *)

 (** [uppercase_ascii s] is [s] with all lowercase letters
     translated to uppercase, using the US-ASCII character set.

-    @since 4.03 (4.05 in StringLabels) *)
+    @since 4.05 *)

 val lowercase_ascii : string -> string
 (** [lowercase_ascii s] is [s] with all uppercase letters translated
     to lowercase, using the US-ASCII character set.

-    @since 4.03 (4.05 in StringLabels) *)
+    @since 4.05 *)

 val capitalize_ascii : string -> string
 (** [capitalize_ascii s] is [s] with the first character set to
     uppercase, using the US-ASCII character set.

-    @since 4.03 (4.05 in StringLabels) *)
+    @since 4.05 *)

 val uncapitalize_ascii : string -> string
 (** [uncapitalize_ascii s] is [s] with the first character set to lowercase,
     using the US-ASCII character set.

-    @since 4.03 (4.05 in StringLabels) *)
+    @since 4.05 *)

 (** {1:traversing Traversing} *)

     privileges.  See the documentation for {!unsafe_getenv} for more
     details.

-    @since 4.06 (4.12 in UnixLabels) *)
+    @since 4.12 *)

 val getenv : string -> string
 (** Return the value associated to a variable in the process
 val fsync : file_descr -> unit
 (** Flush file buffers to disk.

-    @since 4.08 (4.12 in UnixLabels) *)
+    @since 4.12 *)

 val read : file_descr -> bytes -> int -> int -> int
 (** [read fd buf pos len] reads [len] bytes from descriptor [fd],
    [link(2)] function is used whose behaviour is OS-dependent, but more widely
    available.

-   @raise ENOSYS On {e Unix} if [~follow:_] is requested, but linkat is
+   @raise ENOSYS On {e Unix} if [follow:_] is requested, but linkat is
                  unavailable.
-   @raise ENOSYS On {e Windows} if [~follow:false] is requested. *)
+   @raise ENOSYS On {e Windows} if [follow:false] is requested. *)

 val realpath : string -> string
 (** [realpath p] is an absolute pathname for [p] obtained by resolving
    the Unix module that create file descriptors have an optional
    argument [?cloexec:bool] to indicate whether the file descriptor
    should be created in ``close-on-exec'' mode (by writing
-   [~cloexec:true]) or in ``keep-on-exec'' mode (by writing
-   [~cloexec:false]).  For historical reasons, the default file
+   [cloexec:true]) or in ``keep-on-exec'' mode (by writing
+   [cloexec:false]).  For historical reasons, the default file
    descriptor creation mode is ``keep-on-exec'', if no [cloexec] optional
    argument is given.  This is not a safe default, hence it is highly
    recommended to pass explicit [cloexec] arguments to operations that
    completes.  If another thread spawns another program during this window,
    the descriptor will leak, as it is still in the ``keep-on-exec'' mode.

-   Regarding the atomicity guarantees given by [~cloexec:true] or by
+   Regarding the atomicity guarantees given by [cloexec:true] or by
    the use of the [O_CLOEXEC] flag: on all platforms it is guaranteed
    that a concurrently-executing Caml thread cannot leak the descriptor
    by starting a new process.  On Linux, this guarantee extends to
 (** Return the pid of a process opened via {!open_process_in} or
    {!open_process_args_in}.

-    @since 4.08 (4.12 in UnixLabels) *)
+    @since 4.12 *)

 val process_out_pid : out_channel -> int
 (** Return the pid of a process opened via {!open_process_out} or
    {!open_process_args_out}.

-    @since 4.08 (4.12 in UnixLabels) *)
+    @since 4.12 *)

 val process_pid : in_channel * out_channel -> int
 (** Return the pid of a process opened via {!open_process} or
    {!open_process_args}.

-    @since 4.08 (4.12 in UnixLabels) *)
+    @since 4.12 *)

 val process_full_pid : in_channel * out_channel * in_channel -> int
 (** Return the pid of a process opened via {!open_process_full} or
    {!open_process_args_full}.

-    @since 4.08 (4.12 in UnixLabels) *)
+    @since 4.12 *)

 val close_process_in : in_channel -> process_status
 (** Close channels opened by {!open_process_in},

 val symlink : ?to_dir:bool -> string -> string -> unit
 (** [symlink ?to_dir src dst] creates the file [dst] as a symbolic link
-   to the file [src]. On Windows, [~to_dir] indicates if the symbolic link
+   to the file [src]. On Windows, [to_dir] indicates if the symbolic link
    points to a directory or a file; if omitted, [symlink] examines [src]
    using [stat] and picks appropriately, if [src] does not exist then [false]
-   is assumed (for this reason, it is recommended that the [~to_dir] parameter
-   be specified in new code). On Unix, [~to_dir] is ignored.
+   is assumed (for this reason, it is recommended that the [to_dir] parameter
+   be specified in new code). On Unix, [to_dir] is ignored.

    Windows symbolic links are available in Windows Vista onwards. There are some
    important differences between Windows symlinks and their POSIX counterparts.
 (** Stop execution for the given number of seconds.  Like [sleep],
     but fractions of seconds are supported.

-    @since 4.03 (4.12 in UnixLabels) *)
+    @since 4.12 *)

 val times : unit -> process_times
 (** Return the execution times of the process.

       For example, consider the following program:
   {[let size = 100_000_000
-  let a = Float.Array.make size 1.
+  let a = Float.ArrayLabels.make size 1.
   let update a f () =
-     Float.Array.iteri (fun i x -> Float.Array.set a i (f x)) a
+     Float.ArrayLabels.iteri f:(fun i x -> Float.Array.set a i (f x)) a
   let d1 = Domain.spawn (update a (fun x -> x +. 1.))
   let d2 = Domain.spawn (update a (fun x ->  2. *. x +. 1.))
   let () = Domain.join d1; Domain.join d2
   (** {1 Generic interface} *)


-  type (!'a, !'b) t
+  type (!'a, !'b) t = ('a, 'b) Hashtbl.t
   (** The type of hash tables from type ['a] to type ['b]. *)

   val create : ?random:bool -> int -> ('a, 'b) t
      the table.  The table grows as needed, so [n] is just an
      initial guess.

-     The optional [~random] parameter (a boolean) controls whether
+     The optional [random] parameter (a boolean) controls whether
      the internal organization of the hash table is randomized at each
      execution of [Hashtbl.create] or deterministic over all executions.

-     A hash table that is created with [~random] set to [false] uses a
+     A hash table that is created with [random] set to [false] uses a
      fixed hash function ({!hash}) to distribute keys among
      buckets.  As a consequence, collisions between keys happen
      deterministically.  In Web-facing applications or other
      denial-of-service attack: the attacker sends input crafted to
      create many collisions in the table, slowing the application down.

-     A hash table that is created with [~random] set to [true] uses the seeded
+     A hash table that is created with [random] set to [true] uses the seeded
      hash function {!seeded_hash} with a seed that is randomly chosen at hash
      table creation time.  In effect, the hash function used is randomly
      selected among [2^{30}] different hash functions.  All these hash
      or {!iter} is no longer deterministic: elements are enumerated in
      different orders at different runs of the program.

-     If no [~random] parameter is given, hash tables are created
+     If no [random] parameter is given, hash tables are created
      in non-random mode by default.  This default can be changed
      either programmatically by calling {!randomize} or by
      setting the [R] flag in the [OCAMLRUNPARAM] environment variable.

-     @before 4.00 the [~random] parameter was not present and all
+     @before 4.00 the [random] parameter was not present and all
      hash tables were created in non-randomized mode. *)

   val clear : ('a, 'b) t -> unit
       @since 4.03 *)

   val fold :
-    ('a -> 'b -> 'acc -> 'acc) -> ('a, 'b) t -> 'acc -> 'acc
+    f:(key:'a -> 'b -> 'acc -> 'acc) -> ('a, 'b) t -> 'acc -> 'acc
   (** [Hashtbl.fold f tbl init] computes
      [(f kN dN ... (f k1 d1 init)...)],
      where [k1 ... kN] are the keys of all bindings in [tbl],
   val randomize : unit -> unit
   (** After a call to [Hashtbl.randomize()], hash tables are created in
       randomized mode by default: {!create} returns randomized
-      hash tables, unless the [~random:false] optional parameter is given.
+      hash tables, unless the [random:false] optional parameter is given.
       The same effect can be achieved by setting the [R] parameter in
       the [OCAMLRUNPARAM] environment variable.

       Note that once [Hashtbl.randomize()] was called, there is no way
       to revert to the non-randomized default behavior of {!create}.
       This is intentional.  Non-randomized hash tables can still be
-      created using [Hashtbl.create ~random:false].
+      created using [Hashtbl.create random:false].

       @since 4.00 *)

       @since 4.12 *)

   (** @since 4.00 *)
-  type statistics = {
+  type statistics = Hashtbl.statistics = {
     num_bindings: int;
       (** Number of bindings present in the table.
           Same value as returned by {!length}. *)
       (** @since 4.03 *)

       val fold :
-        (key -> 'a -> 'acc -> 'acc) -> 'a t -> 'acc -> 'acc
+        f:(key:key -> 'a -> 'acc -> 'acc) -> 'a t -> 'acc -> 'acc
       val length : 'a t -> int
       val stats: 'a t -> statistics (** @since 4.00 *)

     end
   (** The output signature of the functor {!Make}. *)

-  module Make (H : HashedType) : S with type key = H.t
+    module Make : functor (H : HashedType) -> S
+    with type key = H.t
+     and type 'a t = 'a Hashtbl.Make(H).t
   (** Functor building an implementation of the hashtable structure.
       The functor [Hashtbl.Make] returns a structure containing
       a type [key] of keys and a type ['a t] of hash tables
       (** @since 4.03 *)

       val fold :
-        (key -> 'a -> 'acc -> 'acc) -> 'a t -> 'acc -> 'acc
+        f:(key:key -> 'a -> 'acc -> 'acc) -> 'a t -> 'acc -> 'acc
       val length : 'a t -> int
       val stats: 'a t -> statistics

   (** The output signature of the functor {!MakeSeeded}.
       @since 4.00 *)

-  module MakeSeeded (H : SeededHashedType) : SeededS with type key = H.t
+    module MakeSeeded (H : SeededHashedType) : SeededS
+    with type key = H.t
+     and type 'a t = 'a Hashtbl.MakeSeeded(H).t
   (** Functor building an implementation of the hashtable structure.
       The functor [Hashtbl.MakeSeeded] returns a structure containing
       a type [key] of keys and a type ['a t] of hash tables
       interface, but use the seeded hashing and equality functions
       specified in the functor argument [H] instead of generic
       equality and hashing.  The [create] operation of the
-      result structure supports the [~random] optional parameter
-      and returns randomized hash tables if [~random:true] is passed
+      result structure supports the [random] optional parameter
+      and returns randomized hash tables if [random:true] is passed
       or if randomization is globally on (see {!Hashtbl.randomize}).
       @since 4.00 *)

             (fun c ->
               let count_c =
                 Char_tbl.find_opt counts c
-                |> Option.value ~default:0
+                |> Option.value default:0
               in
               Char_tbl.replace counts c (count_c + 1))
             seq;
     ]}

   *)
+
   (** Association tables over ordered types.

      This module implements applicative association tables, also known as
           @before 4.03 Physical equality was not ensured. *)

       val merge:
-        (key -> 'a option -> 'b option -> 'c option) ->
+        f:(key -> 'a option -> 'b option -> 'c option) ->
         'a t -> 'b t -> 'c t
       (** [merge f m1 m2] computes a map whose keys are a subset of the keys of
           [m1] and of [m2]. The presence of each such binding, and the
           order with respect to the ordering over the type of the keys. *)

       val fold:
-        (key -> 'a -> 'acc -> 'acc) -> 'a t -> 'acc -> 'acc
+        f:(key:key -> 'a -> 'acc -> 'acc) -> 'a t -> 'acc -> 'acc
       (** [fold f m init] computes [(f kN dN ... (f k1 d1 init)...)],
           where [k1 ... kN] are the keys of all bindings in [m]
           (in increasing order), and [d1 ... dN] are the associated data. *)
     end
   (** Output signature of the functor {!Make}. *)

-  module Make (Ord : OrderedType) : S with type key = Ord.t
+    module Make : functor (Ord : OrderedType) -> S
+    with type key = Ord.t
+     and type 'a t = 'a Map.Make(Ord).t
   (** Functor building an implementation of the map structure
      given a totally ordered type. *)
+
   (** Sets over ordered types.

      This module implements the set data structure, given a total ordering
     end
   (** Output signature of the functor {!Make}. *)

-  module Make (Ord : OrderedType) : S with type elt = Ord.t
+    module Make : functor (Ord : OrderedType) -> S
+    with type elt = Ord.t
+     and type t = Set.Make(Ord).t
   (** Functor building an implementation of the set structure
      given a totally ordered type. *)
+
+end
