
#   * * *       #   type 'a t = { t : 'a; }
# type 'a fold = { fold : 'b. f:('b -> 'a -> 'b) -> init:'b -> 'b; }
# val f : 'a list -> 'a fold = <fun>
# - : int = 6
#               class ['a] ilist :
  'a list ->
  object ('b)
    val l : 'a list
    method add : 'a -> 'b
    method fold : f:('c -> 'a -> 'c) -> init:'c -> 'c
  end
#         class virtual ['a] vlist :
  object ('b)
    method virtual add : 'a -> 'b
    method virtual fold : f:('c -> 'a -> 'c) -> init:'c -> 'c
  end
#             class ilist2 :
  int list ->
  object ('a)
    val l : int list
    method add : int -> 'a
    method fold : f:('b -> int -> 'b) -> init:'b -> 'b
  end
#             val ilist2 : 'a list -> 'a vlist = <fun>
#             class ['a] ilist3 :
  'a list ->
  object ('b)
    val l : 'a list
    method add : 'a -> 'b
    method fold : f:('c -> 'a -> 'c) -> init:'c -> 'c
  end
#               class ['a] ilist4 :
  'a list ->
  object ('b)
    val l : 'a list
    method add : 'a -> 'b
    method fold : f:('c -> 'a -> 'c) -> init:'c -> 'c
  end
#                 class ['a] ilist5 :
  'a list ->
  object ('b)
    val l : 'a list
    method add : 'a -> 'b
    method fold : f:('c -> 'a -> 'c) -> init:'c -> 'c
    method fold2 : f:('d -> 'a -> 'd) -> init:'d -> 'd
  end
#                 class ['a] ilist6 :
  'a list ->
  object ('b)
    val l : 'a list
    method add : 'a -> 'b
    method fold : f:('c -> 'a -> 'c) -> init:'c -> 'c
    method fold2 : f:('d -> 'a -> 'd) -> init:'d -> 'd
  end
#       class virtual ['a] olist :
  object method virtual fold : f:('a -> 'b -> 'b) -> init:'b -> 'b end
#         class ['a] onil :
  object method fold : f:('a -> 'b -> 'b) -> init:'b -> 'b end
#             class ['a] ocons :
  hd:'a ->
  tl:'a olist ->
  object
    val hd : 'a
    val tl : 'a olist
    method fold : f:('a -> 'b -> 'b) -> init:'b -> 'b
  end
#               class ['a] ostream :
  hd:'a ->
  tl:'a ostream ->
  object
    val hd : 'a
    val tl : 'a ostream
    method empty : bool
    method fold : f:('a -> 'b -> 'b) -> init:'b -> 'b
  end
#                   class ['a] ostream1 :
  hd:'a ->
  tl:'b ->
  object ('b)
    val hd : 'a
    val tl : 'b
    method fold : f:('a -> 'c -> 'c) -> init:'c -> 'c
    method hd : 'a
    method tl : 'b
  end
#           class vari : object method m : [< `A | `B | `C ] -> int end
#       class vari : object method m : [< `A | `B | `C ] -> int end
#           module V : sig type v = [ `A | `B | `C ] val m : [< v ] -> int end
#         class varj : object method m : [< V.v ] -> int end
#         module type T =
  sig class vari : object method m : [< `A | `B | `C ] -> int end end
#             module M0 :
  sig class vari : object method m : [< `A | `B | `C ] -> int end end
#   module M : T
# val v : M.vari = <obj>
# - : int = 1
#               class point :
  x:int ->
  y:int -> object val x : int val y : int method x : int method y : int end
#           class color_point :
  x:int ->
  y:int ->
  color:string ->
  object
    val color : string
    val x : int
    val y : int
    method color : string
    method x : int
    method y : int
  end
#                   class circle :
  #point ->
  r:int ->
  object val p : point val r : int method distance : #point -> float end
#           val p0 : point = <obj>
val p1 : point = <obj>
val cp : color_point = <obj>
val c : circle = <obj>
val d : float = 11.4536240470737098
#   val f : < m : 'a. 'a -> 'a > -> < m : 'a. 'a -> 'a > = <fun>
#   [A[A# let f (x : < m : 'a. 'a -> 'a list >) = ([4mx[m : < m : 'b. 'b -> 'c >)
  ;;
[mError: This expression has type < m : 'a. 'a -> 'a list >
       but an expression was expected of type < m : 'a. 'a -> 'b >
       The universal variable 'a would escape its scope
#           class id : object method id : 'a -> 'a end
#         class type id_spec = object method id : 'a -> 'a end
#       class id_impl : object method id : 'a -> 'a end
#               class a : object method m : bool end
and b : object method id : 'a -> 'a end
#           [A[A[A[A[A[A# 
  class ['a] id1 = object
    method virtual id : 'b. 'b -> 'a
    method id [4mx = x[m
  end
  ;;
[mError: This method has type 'a -> 'a which is less general than 'b. 'b -> 'a
#         [A[A[A[A[A# class id2 (x : 'a) = object
    method virtual id : 'b. 'b -> 'a
    method id [4mx = x[m
  end
  ;;
[mError: This method has type 'a -> 'a which is less general than 'b. 'b -> 'a
#           [A[A[A[A[A[A# class id3 x = object
    val x = x
    method virtual id : 'a. 'a -> 'a
    method id [4m_ = x[m
  end
  ;;
[mError: This method has type 'a -> 'a which is less general than 'b. 'b -> 'b
#                 [A[A[A[A[A[A[A[A[A# class id4 () = object
    val mutable r = None
    method virtual id : 'a. 'a -> 'a
    method id [4mx =
      match r with
        None -> r <- Some x; x
      | Some y -> y[m
  end
  ;;
[mError: This method has type 'a -> 'a which is less general than 'b. 'b -> 'b
#         class c : object method m : 'a -> 'b -> 'a end
#     val f1 : id -> int * bool = <fun>
#   val f2 : id -> int * bool = <fun>
#   [A[A# let f3 f = f#id 1, f#id [4mtrue[m
  ;;
[mError: This expression has type bool but an expression was expected of type
         int
#   val f4 : id -> int * bool = <fun>
#           class c : object method m : #id -> int * bool end
#             class id2 : object method id : 'a -> 'a method mono : int -> int end
#   val app : int * bool = (1, true)
#   [A[A# type[4m 'a foo = 'a foo list[m
  ;;
[mError: The type abbreviation foo is cyclic
#     class ['a] bar : 'a -> object  end
#   type 'a foo = 'a foo bar
#   - : (< m : 'b. 'b * 'a > as 'a) -> 'c * 'a = <fun>
# - : (< m : 'b. 'a * 'b list > as 'a) -> 'a * 'c list = <fun>
# val f :
  (< m : 'b. 'a * (< n : 'b; .. > as 'b) > as 'a) ->
  'a * (< n : 'c; .. > as 'c) = <fun>
# - : (< p : 'b. < m : 'b; n : 'a; .. > as 'b > as 'a) ->
    (< m : 'c; n : 'a; .. > as 'c)
= <fun>
# - : (< m : 'b. 'b * < p : 'd. 'd * 'c * 'a > as 'c > as 'a) ->
    ('f * < p : 'g. 'g * 'e * 'a > as 'e)
= <fun>
#   - : < m : 'a. < p : 'a; .. > as 'b > -> 'b = <fun>
#   type sum = T of < id : 'a. 'a -> 'a >
# - : sum -> 'a -> 'a = <fun>
#   type record = { r : < id : 'a. 'a -> 'a >; }
# - : record -> 'a -> 'a = <fun>
# - : record -> 'a -> 'a = <fun>
#       class myself : object ('a) method self : 'b -> 'a end
#                       class number :
  object ('a)
    val num : int
    method num : int
    method prev : 'a
    method succ : 'a
    method switch : zero:(unit -> 'b) -> prev:('a -> 'b) -> 'b
  end
#     val id : 'a -> 'a = <fun>
#       class c : object method id : 'a -> 'a end
#         class c' : object method id : 'a -> 'a end
#               class d :
  object
    val mutable count : int
    method count : int
    method id : 'a -> 'a
    method old : 'b -> 'b
  end
#             class ['a] olist :
  'a list ->
  object ('b)
    val l : 'a list
    method cons : 'a -> 'b
    method fold : f:('a -> 'c -> 'c) -> init:'c -> 'c
  end
#   val sum : int #olist -> int = <fun>
#   val count : 'a #olist -> int = <fun>
#     val append : 'a #olist -> ('a #olist as 'b) -> 'b = <fun>
#     type 'a t = unit
#   class o : object method x : [> `A ] t -> unit end
#   class c : object method m : d end
and d : ?x:int -> unit -> object  end
# class d : ?x:int -> unit -> object  end
and c : object method m : d end
#           class type numeral = object method fold : ('a -> 'a) -> 'a -> 'a end
class zero : object method fold : ('a -> 'a) -> 'a -> 'a end
class next : #numeral -> object method fold : ('a -> 'a) -> 'a -> 'a end
#       class type node_type = object method as_variant : [> `Node of node_type ] end
#       class node : node_type
#     class node : object method as_variant : [> `Node of node_type ] end
#   type bad = { bad : 'a. 'a option ref; }
# [A# let bad = {bad = [4mref None[m};;
[mError: This field value has type 'a option ref which is less general than
         'b. 'b option ref
# type bad2 = { mutable bad2 : 'a. 'a option ref option; }
# val bad2 : bad2 = {bad2 = None}
# [A# bad2.bad2 <- [4mSome (ref None)[m;;
[mError: This field value has type 'a option ref option
       which is less general than 'b. 'b option ref option
#       val f : < m : 'a. < p : 'a * 'b > as 'b > -> 'c -> unit = <fun>
# val f : < m : 'a. 'a * (< p : int * 'b > as 'b) > -> 'b -> unit = <fun>
#       type 'a t = [ `A of 'a ]
#       class c : object method m : ([> 'a t ] as 'a) -> unit end
#         class c : object method m : ([> 'a t ] as 'a) -> unit end
#     class c : object method m : ([> 'a t ] as 'a) -> 'a end
#     class c : object method m : ([> `A ] as 'a) option -> 'a end
#           [A[A[A[A[A[A# 
  (* various old bugs *)
  class virtual ['a] visitor =
  object method virtual caseNil : 'a end
  and virtual int_list =
  object method virtual visit : [4m'a.('a visitor -> 'a)[m end;;
[mError: This type scheme cannot quantify 'a :
it escapes this scope.
#                 type ('a, 'b) list_visitor = < caseCons : 'b -> 'b list -> 'a; caseNil : 'a >
type 'a alist = < visit : 'b. ('b, 'a) list_visitor -> 'b >
class type ct = object ('a) method fold : ('b -> 'a -> 'b) -> 'b -> 'b end
type t = { f : 'a 'b. ('b -> (#ct as 'a) -> 'b) -> 'b; }
#     [A[A[A# 
  (* PR#1663 *)
  type [4mt = u[m and u = t;;
[mError: The type abbreviation t is cyclic
#       class ['a] a : object constraint 'a = [> `A of 'a a ] end
type t = [ `A of t a ]
#     [A[A[A# 
  (* Wrong in 3.06 *)
  type ('a,'b) t constraint 'a = 'b and ('a,'b) u = [4m('a,'b) t[m;;
[mError: Constraints are not satisfied in this type.
Type ('a, 'b) t should be an instance of ('c, 'c) t
#     type 'a t = 'a
and u = int t
#     type 'a t constraint 'a = int
# [A# type 'a u = 'a and 'a v = [4m'a u t[m;;
[mError: Constraints are not satisfied in this type.
Type 'a u t should be an instance of int t
# type 'a u = 'a constraint 'a = int
and 'a v = 'a u t constraint 'a = int
#     type g = int
# type 'a t = unit constraint 'a = g
# [A# type 'a u = 'a and 'a v = [4m'a u t[m;;
[mError: Constraints are not satisfied in this type.
Type 'a u t should be an instance of g t
# type 'a u = 'a constraint 'a = g
and 'a v = 'a u t constraint 'a = int
#     [A[A[A# 
  (* Example of wrong expansion *)
  type[4m 'a u = < m : 'a v >[m and 'a v = 'a list u;;
[mError: In the definition of v, type 'a list u should be 'a u
#       type 'a t = 'a
type 'a u = A of 'a t
#     type 'a t = < a : 'a >
# - : ('a t as 'a) -> 'a t = <fun>
# type u = 'a t as 'a
#       type t = A | B
# - : [> `A ] * t -> int = <fun>
# - : [> `A ] * t -> int = <fun>
# - : [> `A ] option * t -> int = <fun>
#   - : [> `A ] option * t -> int = <fun>
# - : t * [< `A | `B ] -> int = <fun>
# - : [< `A | `B ] * t -> int = <fun>
# [A# [4mfunction (`A|`B), _ -> 0 | _,(`A|`B) -> 1[m;;
[mWarning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(`AnyExtraTag, `AnyExtraTag)
- : [> `A | `B ] * [> `A | `B ] -> int = <fun>
# [A# [4mfunction `B,1 -> 1 | _,1 -> 2[m;;
[mWarning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(_, 0)
[A[A[A[A# function `B,1 -> 1 | [4m_,1[m -> 2;;
[m


Warning 11: this match case is unused.
- : [< `B ] * int -> int = <fun>
# [A# [4mfunction 1,`B -> 1 | 1,_ -> 2[m;;
[mWarning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(0, _)
[A[A[A[A# function 1,`B -> 1 | [4m1,_[m -> 2;;
[m


Warning 11: this match case is unused.
- : int * [< `B ] -> int = <fun>
#       [A[A[A[A# 
  (* pass typetexp, but fails during Typedecl.check_recursion *)
  type [4m('a, 'b) a = 'a -> unit constraint 'a = [> `B of ('a, 'b) b as 'b][m 
  and  ('a, 'b) b = 'b -> unit constraint 'b = [> `A of ('a, 'b) a as 'a];;
[mError: Constraints are not satisfied in this type.
Type
([> `B of 'a ], 'a) b as 'a
should be an instance of
(('b, [> `A of 'b ] as 'c) a as 'b, 'c) b
#     *                           class type ['a, 'b] a =
  object
    constraint 'a = < as_a : ('a, 'b) a as 'c; b : 'b; .. >
    constraint 'b = < a : 'a; as_b : ('a, 'b) b; .. >
    method as_a : 'c
    method b : 'b
  end
and ['a, 'b] b =
  object
    constraint 'a = < as_a : ('a, 'b) a; b : 'b; .. >
    constraint 'b = < a : 'a; as_b : ('a, 'b) b; .. >
    method a : 'a
    method as_b : ('a, 'b) b
  end
class type ['a] ca =
  object ('b)
    constraint 'a = < a : 'b; as_b : ('b, 'a) b; .. >
    method as_a : ('b, 'a) a
    method b : 'a
  end
class type ['a] cb =
  object ('b)
    constraint 'a = < as_a : ('a, 'b) a; b : 'b; .. >
    method a : 'a
    method as_b : ('a, 'b) b
  end
type bt = 'a ca cb as 'a
#     class c : object method m : int end
# val f : unit -> c = <fun>
# val f : unit -> c = <fun>
# [A# let f () = [4mobject method private n = 1 method m = {<>}#n end[m;;
[mWarning 15: the following private methods were made public implicitly:
 n.
val f : unit -> < m : int; n : int > = <fun>
# [A# let f () = [4mobject (self:c) method n = 1 method m = 2 end[m;;
[mError: This object is expected to have type c but actually has type
         < m : int; n : 'a >
       The first object type has no method n
# [A# let f () = [4mobject (_:'s) constraint 's = < n : int > method m = 1 end[m;;
[mError: This object is expected to have type < n : int > but actually has type
         < m : 'a >
       The second object type has no method n
#         [A[A[A[A[A# class c = object (_ : 's)
    method x = 1
    method private m =
      [4mobject (self: 's) method x = 3 method private m = self end[m
  end;;
[mError: This object is expected to have type < x : int; .. >
       but actually has type < x : int >
       Self type cannot be unified with a closed object type
#         val o : < x : int > = <obj>
#         [A[A[A[A[A# 
  
  (* Unsound! *)
  fun (x : <m : 'a. 'a * <m: 'b. 'a * 'foo> > as 'foo) ->
    ([4mx[m : <m : 'a. 'a * (<m:'b. 'a * <m:'c. 'c * 'bar> > as 'bar) >);;
[mError: This expression has type < m : 'b. 'b * < m : 'b * 'a > > as 'a
       but an expression was expected of type
         < m : 'b. 'b * (< m : 'b * < m : 'd. 'd * 'c > > as 'c) >
       Types for method m are incompatible
#         [A[A[A[A[A# type 'a foo = <m: 'b. 'a * 'a foo>
  type foo' =   <m: 'a. 'a * 'a foo>
  type 'a bar = <m: 'b. 'a * <m: 'c. 'c * 'a bar> >
  type bar' =   <m: 'a. 'a * 'a bar >
  let f (x : foo') = ([4mx[m : bar');;
[mError: This expression has type foo' = < m : 'a. 'a * 'a foo >
       but an expression was expected of type bar' = < m : 'a. 'a * 'a bar >
       Type 'a foo = < m : 'a * 'a foo > is not compatible with type
         'a bar = < m : 'a * < m : 'b. 'b * 'a bar > > 
       Type 'a foo = < m : 'a * 'a foo > is not compatible with type
         < m : 'b. 'b * 'a bar > 
       Types for method m are incompatible
#     [A[A[A# 
  fun (x : <m : 'a. 'a * ('a * <m : 'a. 'a * 'foo> as 'foo)>) ->
    ([4mx[m : <m : 'b. 'b * ('b * <m : 'c. 'c * ('c * 'bar)>)> as 'bar);;
[mError: This expression has type
         < m : 'a. 'a * ('a * < m : 'c. 'c * 'b > as 'b) >
       but an expression was expected of type
         < m : 'a. 'a * ('a * < m : 'c. 'c * ('c * 'd) >) > as 'd
       Types for method m are incompatible
#   [A[A# fun (x : <m : 'a. 'a * ('a * <m : 'a. 'a * 'foo> as 'foo)>) ->
    ([4mx[m : <m : 'b. 'b * ('b * <m : 'c. 'c * ('b * 'bar)>)> as 'bar);;
[mError: This expression has type
         < m : 'a. 'a * ('a * < m : 'c. 'c * 'b > as 'b) >
       but an expression was expected of type
         < m : 'a. 'a * ('a * < m : 'c. 'c * ('a * 'd) >) > as 'd
       Types for method m are incompatible
#   [A[A# fun (x : <m : 'a. 'a * ('a * 'foo)> as 'foo) ->
    ([4mx[m : <m : 'b. 'b * ('b * <m:'c. 'c * 'bar> as 'bar)>);;
[mError: This expression has type < m : 'b. 'b * ('b * 'a) > as 'a
       but an expression was expected of type
         < m : 'b. 'b * ('b * < m : 'd. 'd * 'c > as 'c) >
       Types for method m are incompatible
#     [A[A[A# let f x =
      [4m(x : <m : 'a. 'a -> ('a * <m:'c. 'c -> 'bar> as 'bar)>
         :> <m : 'a. 'a -> ('a * 'foo)> as 'foo)[m;;
[mError: Type < m : 'a. 'a -> ('a * (< m : 'd. 'd -> 'b as 'e > as 'c) as 'b) >
       is not a subtype of < m : 'a. 'a -> ('a * 'f as 'h) as 'g > as 'f 
#       [A[A[A[A# 
  module M
  : sig val f : (<m : 'b. 'b * ('b * <m:'c. 'c * 'bar> as 'bar)>) -> unit end
  = [4mstruct let f (x : <m : 'a. 'a * ('a * 'foo)> as 'foo) = () end[m;;
[mError: Signature mismatch:
       Modules do not match:
         sig val f : (< m : 'b. 'b * ('b * 'a) > as 'a) -> unit end
       is not included in
         sig
           val f : < m : 'a. 'a * ('a * < m : 'c. 'c * 'b > as 'b) > -> unit
         end
       Values do not match:
         val f : (< m : 'b. 'b * ('b * 'a) > as 'a) -> unit
       is not included in
         val f : < m : 'a. 'a * ('a * < m : 'c. 'c * 'b > as 'b) > -> unit
#     [A[A[A# module M
  : sig type t = <m : 'b. 'b * ('b * <m:'c. 'c * 'bar> as 'bar)> end
  = [4mstruct type t = <m : 'a. 'a * ('a * 'foo)> as 'foo end[m;;
[mError: Signature mismatch:
       Modules do not match:
         sig type t = < m : 'b. 'b * ('b * 'a) > as 'a end
       is not included in
         sig type t = < m : 'a. 'a * ('a * < m : 'c. 'c * 'b > as 'b) > end
       Type declarations do not match:
         type t = < m : 'b. 'b * ('b * 'a) > as 'a
       is not included in
         type t = < m : 'a. 'a * ('a * < m : 'c. 'c * 'b > as 'b) >
#     module M : sig type 'a t type u = < m : 'a. 'a t > end
#   module M : sig type 'a t val f : < m : 'a. 'a t > -> int end
#     module M : sig type 'a t val f : < m : 'a. 'a t > -> int end
#         val f :
  (< m : 'b. 'b -> (< m : 'b. 'b -> 'c * <  > > as 'c) * < .. >; .. > as 'a) ->
  'a -> bool = <fun>
#         type t = [ `A | `B ]
# type v = private [> t ]
# - : t -> v = <fun>
# type u = private [< t ]
# - : u -> v = <fun>
# [A# fun x -> [4m(x : v :> u)[m;;
[mError: Type v = [> `A | `B ] is not a subtype of u = [< `A | `B ] 
# type v = private [< t ]
# [A# fun x -> [4m(x : u :> v)[m;;
[mError: Type u = [< `A | `B ] is not a subtype of v = [< `A | `B ] 
# type p = < x : p >
# type q = private < x : p; .. >
# - : q -> p = <fun>
# [A# fun x -> [4m(x : p :> q)[m;;
[mError: Type p = < x : p > is not a subtype of q = < x : p; .. > 
#       [A[A[A[A# 
  let f1 x =
    [4m(x : <m:'a. (<p:int;..> as 'a) -> int>
      :> <m:'b. (<p:int;q:int;..> as 'b) -> int>)[m;;
[mError: Type < m : 'a. (< p : int; .. > as 'a) -> int > is not a subtype of
         < m : 'b. (< p : int; q : int; .. > as 'b) -> int > 
#     val f2 :
  < m : 'a. (< p : < a : int >; .. > as 'a) -> int > ->
  < m : 'a. (< p : < a : int; b : int >; .. > as 'a) -> int > = <fun>
#     [A[A[A# let f3 x =
    [4m(x : <m:'a. (<p:<a:int;b:int>;..> as 'a) -> int>
      :> <m:'b. (<p:<a:int>;..> as 'b) -> int>)[m;;
[mError: Type < m : 'a. (< p : < a : int; b : int >; .. > as 'a) -> int >
       is not a subtype of < m : 'a. (< p : < a : int >; .. > as 'a) -> int > 
# [A# let f4 x = [4m(x : <p:<a:int;b:int>;..> :> <p:<a:int>;..>)[m;;
[mError: Type < p : < a : int; b : int >; .. > is not a subtype of
         < p : < a : int >; .. > 
The second object type has no method b
#   val f5 :
  < m : 'a. [< `A of < p : int > ] as 'a > ->
  < m : 'a. [< `A of <  > ] as 'a > = <fun>
#   [A[A# let f6 x =
    [4m(x : <m:'a. [< `A of < > ] as 'a> :> <m:'a. [< `A of <p:int> ] as 'a>)[m;;
[mError: Type < m : 'a. [< `A of <  > ] as 'a > is not a subtype of
         < m : 'a. [< `A of < p : int > ] as 'a > 
#     class c : object method id : 'a -> 'a end
# type u = c option
# val just : 'a option -> 'a = <fun>
# val f : c -> 'a -> 'a = <fun>
#     val g : c -> 'a -> 'a = <fun>
#     val h : < id : 'a; .. > -> 'a = <fun>
#       val f : 'a -> int = <fun>
val g : 'a -> int = <fun>
# type 'a t = Leaf of 'a | Node of ('a * 'a) t
#   val depth : 'a t -> int = <fun>
#     [A[A[A# let rec depth : 'a. 'a t -> _ =
    [4mfunction Leaf _ -> 1 | Node x -> 1 + d x[m
  and d x = depth x;; (* fails *)
[mError: This definition has type 'a t -> int which is less general than
         'b. 'b t -> int
#   [A[A# let rec depth : 'a. 'a t -> _ =
    [4mfunction Leaf x -> x | Node x -> 1 + depth x[m;; (* fails *)
[mError: This definition has type int t -> int which is less general than
         'a. 'a t -> int
#   [A[A# let rec depth : 'a. 'a t -> _ =
    [4mfunction Leaf x -> x | Node x -> depth x[m;; (* fails *)
[mError: This definition has type 'a t -> 'a which is less general than
         'b. 'b t -> 'a
#   [A[A# let rec depth : 'a 'b. 'a t -> 'b =
    [4mfunction Leaf x -> x | Node x -> depth x[m;; (* fails *)
[mError: This definition has type 'a. 'a t -> 'a which is less general than
         'b 'c. 'c t -> 'b
#   val r : 'a list * '_b list ref = ([], {contents = []})
val q : unit -> 'a list * '_b list ref = <fun>
# val f : 'a -> 'a = <fun>
# val zero : [> `B of 'a | `Int of int ] as 'a = `Int 0
# [A# let zero : 'a. [< `Int of int] as 'a = [4m`Int 0[m;; (* fails *)
[mError: This expression has type [> `Int of int ]
       but an expression was expected of type [< `Int of int ]
       Types for tag `Int are incompatible
#       type t = { f : 'a. [> `B of 'a | `Int of int ] as 'a; }
val zero : t = {f = `Int 0}
#   [A[A# type t = {f: 'a. [< `Int of int] as 'a}
  let zero = {f = [4m`Int 0[m} ;; (* fails *)
[mError: This expression has type [> `Int of int ]
       but an expression was expected of type [< `Int of int ]
       Types for tag `Int are incompatible
#       val id : 'a -> 'a = <fun>
val neg : int -> bool -> int * bool = <fun>
#                         type t = A of int | B of (int * t) list | C of (string * t) list
val transf : (int -> t) -> t -> t = <fun>
val transf_alist : (int -> t) -> ('a * t) list -> ('a * t) list = <fun>
#         type t = { f : 'a. ('a list -> int) Lazy.t; }
val l : t = {f = <lazy>}
#     type t = { f : 'a. 'a -> unit; }
# - : t = {f = <fun>}
# [A# {f=[4mfun ?x y -> y[m};; (* fail *)
[mError: This field value has type unit -> unit which is less general than
         'a. 'a -> unit
# 
