(**************************************************************************)
(*                                                                        *)
(*                                OCaml                                   *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Regression test for arithmetic instructions *)

(function "testarith" ()
   (let r "R"
   (let d "D"
   (let x (load int "X")
   (let y (load int "Y")
   (let f (load float "F")
   (let g (load float "G")
      (addraset r 0 0)
      (addraset r 1 1)
      (addraset r 2 -1)
      (addraset r 3 256)
      (addraset r 4 65536)
      (addraset r 5 16777216)
      (addraset r 6 -256)
      (addraset r 7 -65536)
      (addraset r 8 -16777216)

      (addraset r 9 (+ x y))
      (addraset r 10 (+ x 1))
      (addraset r 11 (+ x -1))

      (addraset r 12 (+a "R" 8))
      (addraset r 13 (+a "R" y))

      (addraset r 14 (- x y))
      (addraset r 15 (- x 1))
      (addraset r 16 (- x -1))

      (addraset r 17 (- "R" 8))
      (addraset r 18 (- "R" y))

      (addraset r 19 ( * x 2))
      (addraset r 20 ( * 2 x))
      (addraset r 21 ( * x 16))
      (addraset r 22 ( * 16 x))
      (addraset r 23 ( * x 12345))
      (addraset r 24 ( * 12345 x))
      (addraset r 25 ( * x y))

      (addraset r 26 (/ x 2))
      (addraset r 27 (/ x 16))
      (addraset r 28 (/ x 7))
      (addraset r 29 (if (!= y 0) (/ x y) 0))

      (addraset r 30 (mod x 2))
      (addraset r 31 (mod x 16))
      (addraset r 32 (if (!= y 0) (mod x y) 0))

      (addraset r 33 (and x y))
      (addraset r 34 (and x 3))
      (addraset r 35 (and 3 x))

      (addraset r 36 (or x y))
      (addraset r 37 (or x 3))
      (addraset r 38 (or 3 x))

      (addraset r 39 (xor x y))
      (addraset r 40 (xor x 3))
      (addraset r 41 (xor 3 x))

      (addraset r 42 (<< x y))
      (addraset r 43 (<< x 1))
      (addraset r 44 (<< x 8))

      (addraset r 45 (>>u x y))
      (addraset r 46 (>>u x 1))
      (addraset r 47 (>>u x 8))

      (addraset r 48 (>>s x y))
      (addraset r 49 (>>s x 1))
      (addraset r 50 (>>s x 8))

      (addraset r 51 (== x y))
      (addraset r 52 (!= x y))
      (addraset r 53 (< x y))
      (addraset r 54 (> x y))
      (addraset r 55 (<= x y))
      (addraset r 56 (>= x y))
      (addraset r 57 (== x 1))
      (addraset r 58 (!= x 1))
      (addraset r 59 (< x 1))
      (addraset r 60 (> x 1))
      (addraset r 61 (<= x 1))
      (addraset r 62 (>= x 1))

      (addraset r 63 (==a x y))
      (addraset r 64 (!=a x y))
      (addraset r 65 (<a x y))
      (addraset r 66 (>a x y))
      (addraset r 67 (<=a x y))
      (addraset r 68 (>=a x y))
      (addraset r 69 (==a x 1))
      (addraset r 70 (!=a x 1))
      (addraset r 71 (<a x 1))
      (addraset r 72 (>a x 1))
      (addraset r 73 (<=a x 1))
      (addraset r 74 (>=a x 1))

      (addraset r 75 (+ x (<< y 1)))
      (addraset r 76 (+ x (<< y 2)))
      (addraset r 77 (+ x (<< y 3)))
      (addraset r 78 (- x (<< y 1)))
      (addraset r 79 (- x (<< y 2)))
      (addraset r 80 (- x (<< y 3)))

      (floataset d 0 0.0)
      (floataset d 1 1.0)
      (floataset d 2 -1.0)
      (floataset d 3 (+f f g))
      (floataset d 4 (-f f g))
      (floataset d 5 ( *f f g))
      (floataset d 6 (/f f g))

      (floataset d 7 (+f f (+f g 1.0)))
      (floataset d 8 (-f f (+f g 1.0)))
      (floataset d 9 ( *f f (+f g 1.0)))
      (floataset d 10 (/f f (+f g 1.0)))

      (floataset d 11 (+f (+f f 1.0) g))
      (floataset d 12 (-f (+f f 1.0) g))
      (floataset d 13 ( *f (+f f 1.0) g))
      (floataset d 14 (/f (+f f 1.0) g))

      (floataset d 15 (+f (+f f 1.0) (+f g 1.0)))
      (floataset d 16 (-f (+f f 1.0) (+f g 1.0)))
      (floataset d 17 ( *f (+f f 1.0) (+f g 1.0)))
      (floataset d 18 (/f (+f f 1.0) (+f g 1.0)))

      (addraset r 81 (==f f g))
      (addraset r 82 (!=f f g))
      (addraset r 83 (<f f g))
      (addraset r 84 (>f f g))
      (addraset r 85 (<=f f g))
      (addraset r 86 (>=f f g))

      (floataset d 19 (floatofint x))
      (addraset r 87 (intoffloat f))

      (if (and (>= x 0) (< x y))
          (seq (checkbound y x) (addraset r 88 1))
        (addraset r 88 0))

      (if (< 0 y)
          (seq (checkbound y 0) (addraset r 89 1))
        (addraset r 89 0))

      (if (< 5 y)
          (seq (checkbound y 5) (addraset r 90 1))
        (addraset r 90 0))

      (addraset r 91 (let res 1 (if (==f f g) [] (assign res 0)) res))
      (addraset r 92 (let res 1 (if (!=f f g) [] (assign res 0)) res))
      (addraset r 93 (let res 1 (if (<f f g) [] (assign res 0)) res))
      (addraset r 94 (let res 1 (if (>f f g) [] (assign res 0)) res))
      (addraset r 95 (let res 1 (if (<=f f g) [] (assign res 0)) res))
      (addraset r 96 (let res 1 (if (>=f f g) [] (assign res 0)) res))

      (addraset r 97 (==f (+f f 1.0) (+f g 1.0)))
      (addraset r 98 (!=f (+f f 1.0) (+f g 1.0)))
      (addraset r 99 (<f (+f f 1.0) (+f g 1.0)))
      (addraset r 100 (>f (+f f 1.0) (+f g 1.0)))
      (addraset r 101 (<=f (+f f 1.0) (+f g 1.0)))
      (addraset r 102 (>=f (+f f 1.0) (+f g 1.0)))

      (addraset r 103 (==f f (+f g 1.0)))
      (addraset r 104 (!=f f (+f g 1.0)))
      (addraset r 105 (<f f (+f g 1.0)))
      (addraset r 106 (>f f (+f g 1.0)))
      (addraset r 107 (<=f f (+f g 1.0)))
      (addraset r 108 (>=f f (+f g 1.0)))

      (addraset r 109 (==f (+f f 1.0) g))
      (addraset r 110 (!=f (+f f 1.0) g))
      (addraset r 111 (<f (+f f 1.0) g))
      (addraset r 112 (>f (+f f 1.0) g))
      (addraset r 113 (<=f (+f f 1.0) g))
      (addraset r 114 (>=f (+f f 1.0) g))

      (floataset d 20 (+f (floatofint x) 1.0))
      (addraset r 115 (intoffloat (+f f 1.0)))

      (floataset d 21 (+f f (load float "G")))
      (floataset d 22 (+f (load float "G") f))
      (floataset d 23 (-f f (load float "G")))
      (floataset d 24 (-f (load float "G") f))
      (floataset d 25 ( *f f (load float "G")))
      (floataset d 26 ( *f (load float "G") f))
      (floataset d 27 (/f f (load float "G")))
      (floataset d 28 (/f (load float "G") f))

      (floataset d 29 (+f ( *f f 2.0) (load float "G")))
      (floataset d 30 (+f (load float "G") ( *f f 2.0)))
      (floataset d 31 (-f ( *f f 2.0) (load float "G")))
      (floataset d 32 (-f (load float "G") ( *f f 2.0)))
      (floataset d 33 ( *f ( +f f 2.0) (load float "G")))
      (floataset d 34 ( *f (load float "G") ( +f f 2.0)))
      (floataset d 35 (/f ( *f f 2.0) (load float "G")))
      (floataset d 36 (/f (load float "G") ( *f f 2.0)))

      (floataset d 37 (-f f))
      (floataset d 38 (absf f))

      (addraset r 116 (mulh x y))
)))))))
