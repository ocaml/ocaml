Line 7, characters 8-60:
  ........function
      None, None -> 1
    | Some _, Some _ -> 2..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
((Some _, None)|(None, Some _))
val f : 'a option * 'b option -> int = <fun>
type _ t = A : int t | B : bool t | C : char t | D : float t
type (_, _, _, _) u = U : (int, int, int, int) u
type v = E | F | G
Line 5, characters 1-82:
  .function A, A, A, A, A, A, A, _, U, U -> 1
     | A, A, A, _, _, _, _, G, _, _ -> 1
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(A, A, A, A, A, A, B, (E|F), _, _)
Line 6, characters 5-33:
     | A, A, A, _, _, _, _, G, _, _ -> 1
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 56: this match case is unreachable.
Consider replacing it with a refutation case '<pat> -> .'
val f :
  'a t * 'b t * 'c t * 'd t * 'e t * 'f t * 'g t * v * ('a, 'b, 'c, 'd) u *
  ('e, 'f, 'g, 'g) u -> int = <fun>
Line 3, characters 20-48:
  let f (x : int t) = match x with A -> 1 | _ -> 2;; (* warn *)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 4: this pattern-matching is fragile.
It will remain exhaustive when constructors are added to type t.
Line 3, characters 42-43:
  let f (x : int t) = match x with A -> 1 | _ -> 2;; (* warn *)
                                            ^
Warning 56: this match case is unreachable.
Consider replacing it with a refutation case '<pat> -> .'
val f : int t -> int = <fun>
Line 1, characters 53-54:
  let f (x : unit t option) = match x with None -> 1 | _ -> 2 ;; (* warn? *)
                                                       ^
Warning 56: this match case is unreachable.
Consider replacing it with a refutation case '<pat> -> .'
val f : unit t option -> int = <fun>
Line 1, characters 53-59:
  let f (x : unit t option) = match x with None -> 1 | Some _ -> 2 ;; (* warn *)
                                                       ^^^^^^
Warning 56: this match case is unreachable.
Consider replacing it with a refutation case '<pat> -> .'
val f : unit t option -> int = <fun>
val f : int t option -> int = <fun>
Line 1, characters 27-49:
  let f (x : int t option) = match x with None -> 1;; (* warn *)
                             ^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Some A
val f : int t option -> int = <fun>
type 'a box = Box of 'a
type 'a pair = { left : 'a; right : 'a; }
Line 2, characters 49-68:
  let f : (int t box pair * bool) option -> unit = function None -> ();;
                                                   ^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Some ({left=Box A; right=Box A}, _)
val f : (int t box pair * bool) option -> unit = <fun>
val f : (string t box pair * bool) option -> unit = <fun>
Line 1, characters 8-39:
  let f = function {left=Box 0; _ } -> ();;
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
{left=Box 1; _ }
val f : int box pair -> unit = <fun>
Line 1, characters 8-47:
  let f = function {left=Box 0;right=Box 1} -> ();;
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
{left=Box 0; right=Box 0}
val f : int box pair -> unit = <fun>
type _ t = Int : int t | Bool : bool t
val f : 'a t -> 'a = <fun>
val g : int t -> int = <fun>
val h : 'a t -> 'a t -> bool = <fun>
type (_, _) cmp = Eq : ('a, 'a) cmp | Any : ('a, 'b) cmp
module A : sig type a type b val eq : (a, b) cmp end
Line 1, characters 33-51:
  let f : (A.a, A.b) cmp -> unit = function Any -> ()
                                   ^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Eq
val f : (A.a, A.b) cmp -> unit = <fun>
val deep : char t option -> char = <fun>
type zero = Zero
type _ succ = Succ
type (_, _, _) plus =
    Plus0 : (zero, 'a, 'a) plus
  | PlusS : ('a, 'b, 'c) plus -> ('a succ, 'b, 'c succ) plus
val trivial : (zero succ, zero, zero) plus option -> bool = <fun>
val easy : (zero, zero succ, zero) plus option -> bool = <fun>
Line 2, characters 2-24:
    function None -> false
    ^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Some (PlusS _)
val harder : (zero succ, zero succ, zero succ) plus option -> bool = <fun>
val harder : (zero succ, zero succ, zero succ) plus option -> bool = <fun>
val inv_zero : ('a, 'b, 'c) plus -> ('c, 'd, zero) plus -> bool = <fun>
type _ t = Int : int t
val f : bool t -> 'a = <fun>
Line 5, characters 27-28:
  let f () = match None with _ -> .;; (* error *)
                             ^
Error: This match case could not be refuted.
       Here is an example of a value that would reach it: _
Line 1, characters 47-48:
  let g () = match None with _ -> () | exception _ -> .;; (* error *)
                                                 ^
Error: This match case could not be refuted.
       Here is an example of a value that would reach it: _
Line 1, characters 27-28:
  let h () = match None with _ -> .  | exception _ -> .;; (* error *)
                             ^
Error: This match case could not be refuted.
       Here is an example of a value that would reach it: _
val f : 'a option -> unit = <fun>
Line 4, characters 12-42:
  let f x y = match 1 with 1 when x = y -> 1;;
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
All clauses in this pattern-matching are guarded.
val f : 'a -> 'a -> int = <fun>
Line 3, characters 8-37:
  let f = function {contents=_}, 0 -> 0;;
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(_, 1)
val f : 'a ref * int -> int = <fun>
Line 3, characters 8-88:
  ........function
    | None -> ()
    | Some x when x > 0 -> ()
    | Some x when x <= 0 -> ()
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Some _
(However, some guarded clause may match this value.)
val f : int option -> unit = <fun>

