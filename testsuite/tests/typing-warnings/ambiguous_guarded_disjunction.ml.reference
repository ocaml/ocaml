
#                             
<----------------------------------------------------------------------
To check the result file for this test, it suffices to look for "val"
lines corresponding to toplevel answers. If they start with

    val ambiguous_...

then just above there should be the warning text for Warning 57
(we try to avoid all other warnings). If they start with

   val not_ambiguous_...

then just above there should be *no* warning text.
---------------------------------------------------------------------->

#     type expr = Val of int | Rest
#                   Characters 46-71:
    | ((Val x, _) | (_, Val x)) when x < 0 -> ()
      ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 57: Ambiguous guarded or-pattern: the guard variable x
may match incompatible parts of several or-patterns.

When you write [(p | q) when guard], the pattern is matched,
and then the guard tested. If the guard fails, the clause is
not selected. In particular, if a value matches both [p] and [q],
only [p when guard] is tested.

Unfortunately, many code readers wrongly expect this construction
to be equivalent to the imaginary [p when guard | q when guard].
If a value may match both [p] and [q], and [guard] uses
variables bound in different places on both sides, then
those two interpretations differ. This ambiguous code is confusing
and should be avoided.
val ambiguous_typical_example : expr * expr -> unit = <fun>
#   Note that an Assert_failure is expected just below.
#   Exception: Assert_failure ("//toplevel//", 23, 6).
#           val not_ambiguous__no_orpat : int option -> unit = <fun>
#         val not_ambiguous__no_guard : [< `A | `B | `C ] -> unit = <fun>
#         val not_ambiguous__no_patvar_in_guard :
  bool -> [> `B of 'a | `C of 'a ] -> unit = <fun>
#         val not_ambiguous__disjoint_cases : [> `B of bool | `C of bool ] -> unit =
  <fun>
#   * * *         val not_ambiguous__prefix_variables :
  [> `B of bool * 'a option * 'a option ] -> unit = <fun>
#         Characters 33-72:
    | (`B (x, _, Some y) | `B (x, Some y, _)) when y -> ignore x
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 57: Ambiguous guarded or-pattern: the guard variable y
may match incompatible parts of several or-patterns.

When you write [(p | q) when guard], the pattern is matched,
and then the guard tested. If the guard fails, the clause is
not selected. In particular, if a value matches both [p] and [q],
only [p when guard] is tested.

Unfortunately, many code readers wrongly expect this construction
to be equivalent to the imaginary [p when guard | q when guard].
If a value may match both [p] and [q], and [guard] uses
variables bound in different places on both sides, then
those two interpretations differ. This ambiguous code is confusing
and should be avoided.
val ambiguous__y : [> `B of 'a * bool option * bool option ] -> unit = <fun>
#   * * * * * * * * *         val not_ambiguous__rhs_not_protected :
  [> `B of 'a * bool option * bool option ] -> unit = <fun>
#         Characters 35-74:
    | (`B (x, _, Some y) | `B (x, Some y, _)) when x < y -> ()
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 57: Ambiguous guarded or-pattern: the guard variable y
may match incompatible parts of several or-patterns.

When you write [(p | q) when guard], the pattern is matched,
and then the guard tested. If the guard fails, the clause is
not selected. In particular, if a value matches both [p] and [q],
only [p when guard] is tested.

Unfortunately, many code readers wrongly expect this construction
to be equivalent to the imaginary [p when guard | q when guard].
If a value may match both [p] and [q], and [guard] uses
variables bound in different places on both sides, then
those two interpretations differ. This ambiguous code is confusing
and should be avoided.
val ambiguous__x_y : [> `B of 'a * 'a option * 'a option ] -> unit = <fun>
#         Characters 37-76:
    | (`B (x, z, Some y) | `B (x, Some y, z)) when x < y || Some x = z -> ()
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 57: Ambiguous guarded or-pattern: the guard variables y and z
may match incompatible parts of several or-patterns.

When you write [(p | q) when guard], the pattern is matched,
and then the guard tested. If the guard fails, the clause is
not selected. In particular, if a value matches both [p] and [q],
only [p when guard] is tested.

Unfortunately, many code readers wrongly expect this construction
to be equivalent to the imaginary [p when guard | q when guard].
If a value may match both [p] and [q], and [guard] uses
variables bound in different places on both sides, then
those two interpretations differ. This ambiguous code is confusing
and should be avoided.
val ambiguous__x_y_z : [> `B of 'a * 'a option * 'a option ] -> unit = <fun>
#         val not_ambiguous__disjoint_in_depth :
  [> `A of [> `B of bool | `C of bool ] ] -> unit = <fun>
#         val not_ambiguous__prefix_variables_in_depth :
  [> `A of [> `B of bool * [> `C1 | `C2 ] ] ] -> unit = <fun>
#         Characters 43-76:
    | `A (`B (Some x, _) | `B (_, Some x)) when x -> ()
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 57: Ambiguous guarded or-pattern: the guard variable x
may match incompatible parts of several or-patterns.

When you write [(p | q) when guard], the pattern is matched,
and then the guard tested. If the guard fails, the clause is
not selected. In particular, if a value matches both [p] and [q],
only [p when guard] is tested.

Unfortunately, many code readers wrongly expect this construction
to be equivalent to the imaginary [p when guard | q when guard].
If a value may match both [p] and [q], and [guard] uses
variables bound in different places on both sides, then
those two interpretations differ. This ambiguous code is confusing
and should be avoided.
val ambiguous__in_depth :
  [> `A of [> `B of bool option * bool option ] ] -> unit = <fun>
#             val not_ambiguous__several_orpats :
  [> `A of
       [> `B of 'a * 'b option * 'c option ] *
       [> `C of 'a * 'd option * 'e option ] *
       [> `D1 of 'f * 'a * 'g option * 'h | `D2 of 'i * 'a * 'j * 'k option ] ] ->
  unit = <fun>
#           Characters 47-80:
    | `A ((`B (Some x, _) | `B (_, Some x)),
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 57: Ambiguous guarded or-pattern: the guard variable x
may match incompatible parts of several or-patterns.

When you write [(p | q) when guard], the pattern is matched,
and then the guard tested. If the guard fails, the clause is
not selected. In particular, if a value matches both [p] and [q],
only [p when guard] is tested.

Unfortunately, many code readers wrongly expect this construction
to be equivalent to the imaginary [p when guard | q when guard].
If a value may match both [p] and [q], and [guard] uses
variables bound in different places on both sides, then
those two interpretations differ. This ambiguous code is confusing
and should be avoided.
val ambiguous__first_orpat :
  [> `A of
       [> `B of 'a option * 'a option ] *
       [> `C of 'a option * 'b option * 'c option ] ] ->
  unit = <fun>
#           Characters 107-140:
          (`C (Some y, _) | `C (_, Some y))) when x < y -> ()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 57: Ambiguous guarded or-pattern: the guard variable y
may match incompatible parts of several or-patterns.

When you write [(p | q) when guard], the pattern is matched,
and then the guard tested. If the guard fails, the clause is
not selected. In particular, if a value matches both [p] and [q],
only [p when guard] is tested.

Unfortunately, many code readers wrongly expect this construction
to be equivalent to the imaginary [p when guard | q when guard].
If a value may match both [p] and [q], and [guard] uses
variables bound in different places on both sides, then
those two interpretations differ. This ambiguous code is confusing
and should be avoided.
val ambiguous__second_orpat :
  [> `A of
       [> `B of 'a option * 'b option * 'c option ] *
       [> `C of 'a option * 'a option ] ] ->
  unit = <fun>
#           val not_ambiguous__pairs : bool * 'a option * 'b option -> unit = <fun>
#             val not_ambiguous__vars : bool -> unit = <fun>
#         val not_ambiguous__as :
  ('a list * 'b list -> bool) -> 'a list * 'b list -> unit = <fun>
#         val not_ambiguous__as_var : ('a list * 'b -> bool) -> 'a list * 'b -> unit =
  <fun>
#         val not_ambiguous__var_as :
  ('a list * 'b -> bool) -> ('a list * 'b) * 'c option * 'd option -> unit =
  <fun>
#           val not_ambiguous__lazy : ('a list * 'b list) * bool lazy_t -> unit = <fun>
#   type t = A of int * int option * int option | B
#       val not_ambiguous__constructor : t -> unit = <fun>
# 
