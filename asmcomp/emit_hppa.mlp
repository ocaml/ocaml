(***********************************************************************)
(*                                                                     *)
(*                         Caml Special Light                          *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1995 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(* $Id$ *)

(* Emission of HP PA-RISC assembly code *)

(* Must come before open Reg... *)
module StringSet =
  Set.Make(struct
    type t = string
    let compare = compare
  end)

open Misc
open Cmm
open Arch
open Proc
open Reg
open Mach
open Linearize
open Emitaux

(* Tradeoff between code size and code speed *)

let fastcode_flag = ref true

(* Layout of the stack *)
(* Always keep the stack 8-aligned. *)

let stack_offset = ref 0

let frame_size () =
  let size =
    !stack_offset +
    4 * num_stack_slots.(0) + 8 * num_stack_slots.(1) +
    (if !contains_calls then 4 else 0) in
  Misc.align size 8

let slot_offset loc cl =
  match loc with
    Incoming n -> -frame_size() - n
  | Local n ->
      if cl = 0
      then - !stack_offset - num_stack_slots.(1) * 8 - n * 4 - 4
      else - !stack_offset - n * 8 - 8
  | Outgoing n -> -n

(* Output a label *)

let emit_label lbl =
  emit_string "L"; emit_int lbl

(* Output a symbol *)

let emit_symbol s =
  emit_string "_"; Emitaux.emit_symbol '$' s

(* Output a pseudo-register *)

let emit_reg r =
  match r.loc with
    Reg r -> emit_string (register_name r)
  | _ -> fatal_error "Emit.emit_reg"

(***********

(* Record imported symbols *)

let used_symbols = ref StringSet.empty
let defined_symbols = ref StringSet.empty
let called_symbols = ref StringSet.empty

let use_symbol s =
  used_symbols := StringSet.add s !used_symbols
let define_symbol s =
  defined_symbols := StringSet.add s !defined_symbols
let call_symbol s =
  used_symbols := StringSet.add s !used_symbols;
  called_symbols := StringSet.add s !called_symbols

(* An external symbol is code if either it is branched to, or
   it does not start with an uppercase letter. *)

let emit_import s =
  if not(StringSet.mem s !defined_symbols) then begin
    `	.import	{emit_symbol s}`;
    if StringSet.mem s !called_symbols or s.[0] < 'A' or s.[0] > 'Z'
    then `, CODE\n`
    else `, DATA\n`
  end

let emit_imports () =
  StringSet.iter emit_import !used_symbols;
  used_symbols := StringSet.empty;
  defined_symbols := StringSet.empty;
  called_symbols := StringSet.empty

************)

(* Output an integer load / store *)

let is_offset n = (n < 8192) & (n >= -8192) (* 14 bits *)

let emit_load instr addr arg dst =
  match addr with
    Ibased(s, 0) ->
        `	ldil	L\`{emit_symbol s}, %r1\n`;
        `	{emit_string instr}	R\`{emit_symbol s}(%r1), {emit_reg dst}\n`
  | Ibased(s, ofs) ->
        `	ldil	L\`{emit_symbol s}+{emit_int ofs}, %r1\n`;
        `	{emit_string instr}	R\`{emit_symbol s}+{emit_int ofs}(%r1), {emit_reg dst}\n`
  | Iindexed ofs ->
      if is_offset ofs then
        `	{emit_string instr}	{emit_int ofs}({emit_reg arg.(0)}), {emit_reg dst}\n`
      else begin
        `	addil	L\`{emit_int ofs}, {emit_reg arg.(0)}\n`;
        `	{emit_string instr}	R\`{emit_int ofs}(%r1), {emit_reg dst}\n`
      end

let emit_store instr addr arg src =
  match addr with
    Ibased(s, 0) ->
        `	ldil	L\`{emit_symbol s}, %r1\n`;
        `	{emit_string instr}	{emit_reg src}, R\`{emit_symbol s}(%r1)\n`
  | Ibased(s, ofs) ->
        `	ldil	L\`{emit_symbol s}+{emit_int ofs}, %r1\n`;
        `	{emit_string instr}	{emit_reg src}, R\`{emit_symbol s}+{emit_int ofs}(%r1)\n`
  | Iindexed ofs ->
      if is_offset ofs then
        `	{emit_string instr}	{emit_reg src}, {emit_int ofs}({emit_reg arg.(1)})\n`
      else begin
        `	addil	L\`{emit_int ofs}, {emit_reg arg.(0)}\n`;
        `	{emit_string instr}	{emit_reg src}, R\`{emit_int ofs}(%r1)\n`
      end

(* Output a floating-point load / store *)

let emit_float_load addr arg dst =
  match addr with
    Ibased(s, 0) ->
        `	ldil	L\`{emit_symbol s}, %r1\n`;
        `	ldo	R\`{emit_symbol s}(%r1), %r1\n`;
        `	fldws	0(%r1), {emit_reg dst}L\n`;
        `	fldws	4(%r1), {emit_reg dst}R\n`
  | Ibased(s, ofs) ->
        `	ldil	L\`{emit_symbol s}+{emit_int ofs}, %r1\n`;
        `	ldo	R\`{emit_symbol s}+{emit_int ofs}(%r1), %r1\n`;
        `	fldws	0(%r1), {emit_reg dst}L\n`;
        `	fldws	4(%r1), {emit_reg dst}R\n`
  | Iindexed ofs ->
      if is_immediate ofs & is_immediate (ofs+4) then begin
        `	fldws	{emit_int ofs}({emit_reg arg.(0)}), {emit_reg dst}L\n`;
        `	fldws	{emit_int (ofs+4)}({emit_reg arg.(0)}), {emit_reg dst}R\n`
      end else begin
        if is_offset ofs then
          `	ldo	{emit_int ofs}({emit_reg arg.(0)}), %r1\n`
        else begin
          `	addil	L\`{emit_int ofs}, {emit_reg arg.(0)}\n`;
          `	ldo	R\`{emit_int ofs}(%r1), %r1\n`
        end;
        `	fldws	0(%r1), {emit_reg dst}L\n`;
        `	fldws	4(%r1), {emit_reg dst}R\n`
      end

let emit_float_store addr arg src =
  match addr with
    Ibased(s, 0) ->
        `	ldil	L\`{emit_symbol s}, %r1\n`;
        `	ldo	R\`{emit_symbol s}(%r1), %r1\n`;
        `	fstws	{emit_reg src}L, 0(%r1)\n`;
        `	fstws	{emit_reg src}R, 4(%r1)\n`
  | Ibased(s, ofs) ->
        `	ldil	L\`{emit_symbol s}+{emit_int ofs}, %r1\n`;
        `	ldo	R\`{emit_symbol s}+{emit_int ofs}(%r1), %r1\n`;
        `	fstws	{emit_reg src}L, 0(%r1)\n`;
        `	fstws	{emit_reg src}R, 4(%r1)\n`
  | Iindexed ofs ->
      if is_immediate ofs & is_immediate (ofs+4) then begin
        `	fstws	{emit_reg src}L, {emit_int ofs}({emit_reg arg.(1)})\n`;
        `	fstws	{emit_reg src}R, {emit_int(ofs+4)}({emit_reg arg.(1)})\n`
      end else begin
        if is_offset ofs then
          `	ldo	{emit_int ofs}({emit_reg arg.(1)}), %r1\n`
        else begin
          `	addil	L\`{emit_int ofs}, {emit_reg arg.(1)}\n`;
          `	ldo	R\`{emit_int ofs}(%r1), %r1\n`
        end;
        `	fstws	{emit_reg src}L, 0(%r1)\n`;
        `	fstws	{emit_reg src}R, 4(%r1)\n`
      end

(* Record live pointers at call points *)

type frame_descr =
  { fd_lbl: int;                        (* Return address *)
    fd_frame_size: int;                 (* Size of stack frame *)
    fd_live_offset: int list }          (* Offsets/regs of live addresses *)

let frame_descriptors = ref([] : frame_descr list)

let record_frame live =
  let lbl = new_label() in
  let live_offset = ref [] in
  Reg.Set.iter
    (function
        {typ = Addr; loc = Reg r} ->
          live_offset := ((r lsl 1) + 1) :: !live_offset
      | {typ = Addr; loc = Stack s} as reg ->
          live_offset := slot_offset s (register_class reg) :: !live_offset
      | _ -> ())
    live;
  frame_descriptors :=
    { fd_lbl = lbl;
      fd_frame_size = frame_size();
      fd_live_offset = !live_offset } :: !frame_descriptors;
  `{emit_label lbl}:\n`

let emit_frame fd =
  `	.long	{emit_label fd.fd_lbl} + 3\n`;
  `	.short	{emit_int fd.fd_frame_size}\n`;
  `	.short	{emit_int (List.length fd.fd_live_offset)}\n`;
  List.iter
    (fun n ->
      `	.short	{emit_int n}\n`)
    fd.fd_live_offset;
  `	.align	2\n`

(* Record floating-point constants *)

let float_constants = ref ([] : (int * string) list)

let emit_float_constant (lbl, cst) =
  `	.literal8\n`;
  `	.align	3\n`;
  `{emit_label lbl}:	.double	{emit_string cst}\n`

(* Record external calls and generate stub code for these *)

let defined_functions = ref StringSet.empty

let stub_label_table = (Hashtbl.new 19 : (string, int) Hashtbl.t)

let stub_label symb =
  try
    Hashtbl.find stub_label_table symb
  with Not_found ->
    let lbl = new_label() in
    Hashtbl.add stub_label_table symb lbl;
    lbl

let emit_stub symb lbl =
  `{emit_label lbl}:	ldil	L\`{emit_symbol symb}, %r1\n`;
  `	ble,n	R\`{emit_symbol symb}(4, %r1)\n`

let emit_stubs () =
  `	.text\n`;
  `	.align	2\n`;
  Hashtbl.iter emit_stub stub_label_table

(* Names of various instructions *)

let name_for_int_operation = function
    Iadd -> "add"
  | Isub -> "sub"
  | Iand -> "and"
  | Ior -> "or"
  | Ixor -> "xor"
  | _ -> Misc.fatal_error "Emit.name_for_int_operation"

let name_for_float_operation = function
    Iaddf -> "fadd,dbl"
  | Isubf -> "fsub,dbl"
  | Imulf -> "fmpy,dbl"
  | Idivf -> "fdiv,dbl"
  | _ -> Misc.fatal_error "Emit.name_for_float_operation"

let name_for_specific_operation = function
    Ishift1add -> "sh1add"
  | Ishift2add -> "sh2add"
  | Ishift3add -> "sh3add"

let name_for_int_comparison = function
    Isigned Ceq -> "="      | Isigned Cne -> "<>"
  | Isigned Cle -> "<="     | Isigned Cgt -> ">"
  | Isigned Clt -> "<"      | Isigned Cge -> ">="
  | Iunsigned Ceq -> "="    | Iunsigned Cne -> "<>"
  | Iunsigned Cle -> "<<="  | Iunsigned Cgt -> ">>"
  | Iunsigned Clt -> "<<"   | Iunsigned Cge -> ">>="

let name_for_float_comparison cmp neg =
  match cmp with
    Ceq -> if neg then "=" else "!="
  | Cne -> if neg then "!=" else "="
  | Cle -> if neg then "<=" else "!<="
  | Cgt -> if neg then ">" else "!>"
  | Clt -> if neg then "<" else "!<"
  | Cge -> if neg then ">=" else "!>="

let negate_int_comparison = function
    Isigned cmp -> Isigned(Cmm.negate_comparison cmp)
  | Iunsigned cmp -> Iunsigned(Cmm.negate_comparison cmp)

let swap_int_comparison = function
    Isigned cmp -> Isigned(Cmm.swap_comparison cmp)
  | Iunsigned cmp -> Iunsigned(Cmm.swap_comparison cmp)


(* Output the assembly code for an instruction *)

(* Name of current function *)
let function_name = ref ""
(* Entry point for tail recursive calls *)
let tailrec_entry_point = ref 0
(* Label of trap for out-of-range accesses *)
let range_check_trap = ref 0

let rec emit_instr i dslot =
    match i.desc with
      Lend -> ()
    | Lop(Imove | Ispill | Ireload) ->
        let src = i.arg.(0) and dst = i.res.(0) in
        begin match (src, dst) with
            {loc = Reg rs; typ = (Int | Addr)}, {loc = Reg rd} ->
              `	copy	{emit_reg src}, {emit_reg dst}\n`
          | {loc = Reg rs; typ = Float}, {loc = Reg rd; typ = Float} ->
              `	fcpy,dbl {emit_reg src}, {emit_reg dst}\n`
          | {loc = Reg rs; typ = (Int | Addr)}, {loc = Stack sd} ->
              let ofs = slot_offset sd 0 in
              `	stw	{emit_reg src}, {emit_int ofs}(%r30)\n`
          | {loc = Reg rs; typ = Float}, {loc = Stack sd} ->
              let ofs = slot_offset sd 1 in
              if is_immediate ofs then
              `	fstds   {emit_reg src}, {emit_int ofs}(%r30)\n`
              else begin
              `	ldo	{emit_int ofs}(%r30), %r1\n`;
              `	fstds	{emit_reg src}, 0(%r1)\n`
              end
          | {loc = Stack ss; typ = (Int | Addr)}, {loc = Reg rd} ->
              let ofs = slot_offset ss 0 in
              `	ldw	{emit_int ofs}(%r30), {emit_reg dst}\n`
          | {loc = Stack ss; typ = Float}, {loc = Reg rd} ->
              let ofs = slot_offset ss 1 in
              if is_immediate ofs then
              `	fldds	{emit_int ofs}(%r30), {emit_reg dst}\n`
              else begin
              `	ldo	{emit_int ofs}(%r30), %r1\n`;
              `	fldds	0(%r1), {emit_reg dst}\n`
              end
          | (_, _) ->
              fatal_error "Emit: Imove"
        end
    | Lop(Iconst_int n) ->
        if is_offset n then
          `	ldi	{emit_int n}, {emit_reg i.res.(0)}\n`
        else begin
          `	ldil	L\`{emit_int n}, {emit_reg i.res.(0)}\n`;
          `	ldo	R\`{emit_int n}({emit_reg i.res.(0)}), {emit_reg i.res.(0)}\n`
        end
    | Lop(Iconst_float s) ->
        let lbl = new_label() in
        float_constants := (lbl, s) :: !float_constants;
        `	ldil	L\`{emit_label lbl}, %r1\n`;
        `	ldo	R\`{emit_label lbl}(%r1), %r1\n`;
        `	fldds	0(%r1), {emit_reg i.res.(0)}\n`
    | Lop(Iconst_symbol s) ->
        `	ldil	L\`{emit_symbol s}, {emit_reg i.res.(0)}\n`;
        `	ldo	R\`{emit_symbol s}({emit_reg i.res.(0)}), {emit_reg i.res.(0)}\n`
    | Lop(Icall_ind) ->
        `	ble	0(4, {emit_reg i.arg.(0)})\n`; (* retaddr in %r31 *)
        `	copy	%r31, %r2\n`; (* in delay slot: save retaddr in %r2 *)
        record_frame i.live
    | Lop(Icall_imm s) ->
        if StringSet.mem s !defined_functions then
          `	bl	{emit_symbol s}, %r2\n`
        else begin
          let lbl = stub_label s in
          `	jbsr	{emit_symbol s}, %r2, {emit_label lbl}\n`
        end;
        fill_delay_slot dslot;
        record_frame i.live
    | Lop(Itailcall_ind) ->
        let n = frame_size() in
        if !contains_calls then
          `	ldw	{emit_int(-n)}(%r30), %r2\n`;
        `	bv	0({emit_reg i.arg.(0)})\n`;
        `	ldo	{emit_int(-n)}(%r30), %r30\n` (* in delay slot *)
    | Lop(Itailcall_imm s) ->
        let n = frame_size() in
        if s = !function_name then begin
          `	b,n	{emit_label !tailrec_entry_point}\n`
        end else begin
          if !contains_calls then
            `	ldw	{emit_int(-n)}(%r30), %r2\n`;
          if StringSet.mem s !defined_functions then
            `	bl	{emit_symbol s}, %r0\n`
          else begin
            let lbl = stub_label s in
            `	jbsr	{emit_symbol s}, %r0, {emit_label lbl}\n`
          end;
          `	ldo	{emit_int(-n)}(%r30), %r30\n` (* in delay slot *)
        end
    | Lop(Iextcall(s, alloc)) ->
        if alloc then begin
          `	ldil	L\`{emit_symbol s}, %r22\n`;
          `	bl	{emit_symbol "caml_c_call"}, %r2\n`;
          `	ldo	R\`{emit_symbol s}(%r22), %r22\n`; (* in delay slot *)
          record_frame i.live
        end else begin
          let lbl = stub_label s in
          `	jbsr	{emit_symbol s}, %r2, {emit_label lbl}\n`;
          fill_delay_slot dslot
        end
    | Lop(Istackoffset n) ->
        `	ldo	{emit_int n}(%r30), %r30\n`;
        stack_offset := !stack_offset + n
    | Lop(Iload(chunk, addr)) ->
        begin match i.res.(0).typ with
          Int | Addr ->
            let loadinstr =
              match chunk with
                Word -> "ldw"
              | Byte_unsigned | Byte_signed -> "ldb"
              | Sixteen_unsigned | Sixteen_signed -> "ldh" in
            emit_load loadinstr addr i.arg i.res.(0);
            begin match chunk with
              Byte_signed ->
                `	extrs	{emit_reg i.res.(0)}, 31, 8, {emit_reg i.res.(0)}\n`
            | Sixteen_signed ->
                `	extrs	{emit_reg i.res.(0)}, 31, 16, {emit_reg i.res.(0)}\n`
            | _ -> ()
            end
        | Float ->
            emit_float_load addr i.arg i.res.(0)
        end
    | Lop(Istore(chunk, addr)) ->
        begin match i.arg.(0).typ with
          Int | Addr ->
            let storeinstr =
              match chunk with
                Word -> "stw"
              | Byte_unsigned | Byte_signed -> "stb"
              | Sixteen_unsigned | Sixteen_signed -> "sth" in
            emit_store storeinstr addr i.arg i.arg.(0)
        | Float ->
            emit_float_store addr i.arg i.arg.(0)
        end
    | Lop(Ialloc n) ->
        if !fastcode_flag then begin
          let lbl_cont = new_label() in
          let lbl_stub = stub_label "caml_call_gc" in
          `	ldw	0(%r4), %r1\n`;
          `	ldo	{emit_int (-n)}(%r3), %r3\n`;
          `	comb,>>= %r3, %r1, {emit_label lbl_cont}\n`;
          `	addi	4, %r3, {emit_reg i.res.(0)}\n`; (* in delay slot *)
          `	jbsr	{emit_symbol "caml_call_gc"}, %r2, {emit_label lbl_stub}\n`;
          `	ldi	{emit_int n}, %r1\n`; (* in delay slot *)
          record_frame i.live;
          `	addi	4, %r3, {emit_reg i.res.(0)}\n`;
          `{emit_label lbl_cont}:\n`
        end else begin
          let lbl_stub = stub_label "caml_alloc" in
          `	jbsr	{emit_symbol "caml_alloc"}, %r2, {emit_label lbl_stub}\n`;
          `	ldi	{emit_int n}, %r1\n`; (* in delay slot *)
          record_frame i.live;
          `	addi	4, %r3, {emit_reg i.res.(0)}\n` (* in delay slot *)
        end
    | Lop(Iintop Imul) ->
        `	stws,ma	{emit_reg i.arg.(0)}, 8(%r30)\n`;
        `	stw	{emit_reg i.arg.(1)}, -4(%r30)\n`;
        `	fldws	-8(%r30), %fr31L\n`;
        `	fldws	-4(%r30), %fr31R\n`;
        `	xmpyu	%fr31L, %fr31R, %fr31\n`;
        `	fstws	%fr31R, -8(%r30)\n`; (* poor scheduling *)
        `	ldws,mb	-8(%r30), {emit_reg i.res.(0)}\n`
    | Lop(Iintop Idiv) ->
        (* Arguments are assumed to be in %r26 and %r25, result in %r29 *)
        `	ldil	L\`$$divI, %r1\n`;
        `	ble	R\`$$divI(4, %r1)\n`;
        `	nop\n`
    | Lop(Iintop Imod) ->
        (* Arguments are assumed to be in %r26 and %r25, result in %r29 *)
        `	ldil	L\`$$remI, %r1\n`;
        `	ble	R\`$$remI(4, %r1)\n`;
        `	nop\n`
    | Lop(Iintop Ilsl) ->
        `	subi	31, {emit_reg i.arg.(1)}, %r1\n`;
        `	mtsar	%r1\n`;
        `	zvdep	{emit_reg i.arg.(0)}, 32, {emit_reg i.res.(0)}\n`
    | Lop(Iintop Ilsr) ->
        `	mtsar	{emit_reg i.arg.(1)}\n`;
        `	vshd	%r0, {emit_reg i.arg.(0)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintop Iasr) ->
        `	subi	31, {emit_reg i.arg.(1)}, %r1\n`;
        `	mtsar	%r1\n`;
        `	vextrs	{emit_reg i.arg.(0)}, 32, {emit_reg i.res.(0)}\n`
    | Lop(Iintop(Icomp cmp)) ->
        let comp = name_for_int_comparison(negate_int_comparison cmp) in
        `	comclr,{emit_string comp} {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.res.(0)}\n`;
        `	ldi	1, {emit_reg i.res.(0)}\n`
    | Lop(Iintop Icheckbound) ->
        if !range_check_trap = 0 then range_check_trap := new_label();
        `	comb,<<=,n {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_label !range_check_trap}\n`
        (* Forward branch -> nullify if taken *)
    | Lop(Iintop op) ->
        let instr = name_for_int_operation op in
        `	{emit_string instr}	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Iadd, n)) ->
        `	addi	{emit_int n}, {emit_reg i.arg.(0)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Isub, n)) ->
        `	addi	{emit_int(-n)}, {emit_reg i.arg.(0)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Idiv, n)) ->
        let l = Misc.log2 n in
        `	comclr,>= {emit_reg i.arg.(0)}, %r0, %r1\n`;
        `	zdepi	-1, 31, {emit_int l}, %r1\n`;
        `	add	{emit_reg i.arg.(0)}, %r1, %r1\n`;
        `	extrs	%r1, {emit_int(31-l)}, {emit_int(32-l)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Imod, n)) ->
        let l = Misc.log2 n in
        `	comclr,>= {emit_reg i.arg.(0)}, %r0, %r1\n`;
        `	zdepi	-1, 31, {emit_int l}, %r1\n`;
        `	add	{emit_reg i.arg.(0)}, %r1, %r1\n`;
        `	depi	0, 31, {emit_int l}, %r1\n`;
        `	sub	{emit_reg i.arg.(0)}, %r1, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Ilsl, n)) ->
        let n = n land 31 in
        `	zdep	{emit_reg i.arg.(0)}, {emit_int(31-n)}, {emit_int(32-n)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Ilsr, n)) ->
        let n = n land 31 in
        `	extru	{emit_reg i.arg.(0)}, {emit_int(31-n)}, {emit_int(32-n)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Iasr, n)) ->
        let n = n land 31 in
        `	extrs	{emit_reg i.arg.(0)}, {emit_int(31-n)}, {emit_int(32-n)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Icomp cmp, n)) ->
        let comp = name_for_int_comparison(negate_int_comparison(swap_int_comparison cmp)) in
        `	comiclr,{emit_string comp} {emit_int n}, {emit_reg i.arg.(0)}, {emit_reg i.res.(0)}\n`;
        `	ldi	1, {emit_reg i.res.(0)}\n`
    | Lop(Iintop_imm(Icheckbound, n)) ->
        if !range_check_trap = 0 then range_check_trap := new_label();
        `	comib,>>=,n {emit_int n}, {emit_reg i.arg.(0)}, {emit_label !range_check_trap}\n`
        (* Forward branch -> nullify if taken *)
    | Lop(Iintop_imm(op, n)) ->
        fatal_error "Emit_hppa: Iintop_imm"
    | Lop(Iaddf | Isubf | Imulf | Idivf as op) ->
        let instr = name_for_float_operation op in
        `	{emit_string instr} {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.res.(0)}\n`
    | Lop(Inegf) ->
        `	fsub,dbl 0, {emit_reg i.arg.(0)}, {emit_reg i.res.(0)}\n`
    | Lop(Iabsf) ->
        `	fabs,dbl {emit_reg i.arg.(0)}, {emit_reg i.res.(0)}\n`
    | Lop(Ifloatofint) ->
        `	stws,ma	{emit_reg i.arg.(0)}, 8(%r30)\n`;
        `	fldws,mb -8(%r30), %fr31L\n`;
        `	fcnvxf,sgl,dbl %fr31L, {emit_reg i.res.(0)}\n`
    | Lop(Iintoffloat) ->
        `	fcnvfxt,dbl,sgl {emit_reg i.arg.(0)}, %fr31L\n`;
        `	fstws,ma %fr31L, 8(%r30)\n`;
        `	ldws,mb	-8(%r30), {emit_reg i.res.(0)}\n`
    | Lop(Ispecific sop) ->
        let instr = name_for_specific_operation sop in
        `	{emit_string instr}	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.res.(0)}\n`
    | Lreloadretaddr ->
        let n = frame_size() in
        `	ldw	{emit_int(-n)}(%r30), %r2\n`
    | Lreturn ->
        let n = frame_size() in
        (* Clear mark bit even if this is a leaf routine,
           as the return address may come from a tailcall. *)
        `	depi	0, 0, 1, %r2\n`;
        `	bv	0(%r2)\n`;
        `	ldo	{emit_int(-n)}(%r30), %r30\n`
    | Llabel lbl ->
        `{emit_label lbl}:\n`
    | Lbranch lbl ->
        begin match dslot with
            None ->
              `	b,n	{emit_label lbl}\n`
          | Some i ->
              `	b	{emit_label lbl}\n`;
              emit_instr i None
        end
    | Lcondbranch(tst, lbl) ->
        begin match tst with
          Itruetest ->
            `	comib,<> 0, {emit_reg i.arg.(0)}, {emit_label lbl}\n`
        | Ifalsetest ->
            `	comib,=	0, {emit_reg i.arg.(0)}, {emit_label lbl}\n`
        | Iinttest cmp ->
            let comp = name_for_int_comparison cmp in
            `	comb,{emit_string comp} {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_label lbl}\n`
        | Iinttest_imm(cmp, n) ->
            let comp = name_for_int_comparison(swap_int_comparison cmp) in
            `	comib,{emit_string comp} {emit_int n}, {emit_reg i.arg.(0)}, {emit_label lbl}\n`
        | Ifloattest(cmp, neg) ->
            let comp = name_for_float_comparison cmp neg in
            `	fcmp,dbl,{emit_string comp}	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            `	ftest\n`;
            `	b	{emit_label lbl}\n`
        | Ioddtest ->
            `	comib,OD 0, {emit_reg i.arg.(0)}, {emit_label lbl}\n`
        | Ieventest ->
            `	comib,EV 0, {emit_reg i.arg.(0)}, {emit_label lbl}\n`
        end;
        fill_delay_slot dslot
  | Lcondbranch3(lbl0, lbl1, lbl2) ->
        begin match lbl0 with
          None -> ()
        | Some lbl -> `	comib,= 0, {emit_reg i.arg.(0)}, {emit_label lbl}\n	nop\n`
        end;
        begin match lbl1 with
          None -> ()
        | Some lbl -> `	comib,= 1, {emit_reg i.arg.(0)}, {emit_label lbl}\n	nop\n`
        end;
        begin match lbl2 with
          None -> ()
        | Some lbl -> `	comib,= 2, {emit_reg i.arg.(0)}, {emit_label lbl}\n	nop\n`
        end
    | Lswitch jumptbl ->
        `	blr	{emit_reg i.arg.(0)}, 0\n`;
        fill_delay_slot dslot;
        for i = 0 to Array.length jumptbl - 1 do
          `	b	{emit_label jumptbl.(i)}\n`;
          `	nop\n`
        done
    | Lsetuptrap lbl ->
        `	bl	{emit_label lbl}, %r1\n`;
        fill_delay_slot dslot
    | Lpushtrap ->
        stack_offset := !stack_offset + 8;
        `	stws,ma	%r5, 8(%r30)\n`;
        `	stw	%r1, -4(%r30)\n`;
        `	copy	%r30, %r5\n`
    | Lpoptrap ->
        `	ldws,mb	-8(%r30), %r5\n`;
        stack_offset := !stack_offset - 8
    | Lraise ->
        `	ldw	-4(%r5), %r1\n`;
        `	copy	%r5, %r30\n`;
        `	bv	0(%r1)\n`;
        `	ldws,mb	-8(%r30), %r5\n` (* in delay slot *)

and fill_delay_slot = function
    None -> `	nop\n`
  | Some i -> emit_instr i None

(* Checks if a pseudo-instruction expands to exactly one machine instruction
   that does not branch. *)

let is_one_instr i =
  match i.desc with
    Lop op ->
      begin match op with
        Imove | Ispill | Ireload ->
          begin match (i.arg.(0), i.res.(0)) with
            ({typ = Float; loc = Stack s}, _) -> is_immediate(slot_offset s 1)
          | (_, {typ = Float; loc = Stack s}) -> is_immediate(slot_offset s 1)
          | (_, _) -> true
          end
      | Iconst_int n -> is_offset n
      | Istackoffset _ -> true
      | Iload(_, Iindexed n) -> i.res.(0).typ <> Float & is_offset n
      | Istore(_, Iindexed n) -> i.arg.(0).typ <> Float & is_offset n
      | Iintop(Iadd | Isub | Iand | Ior | Ixor | Icheckbound) -> true
      | Iintop_imm((Iadd | Isub | Ilsl | Ilsr | Iasr | Icheckbound), _) -> true
      | Inegf | Iabsf | Iaddf | Isubf | Imulf | Idivf -> true
      | Ispecific _ -> true
      | _ -> false
      end
  | Lreloadretaddr -> true
  | _ -> false

let no_interference res arg =
  try
    for i = 0 to Array.length arg - 1 do
      for j = 0 to Array.length res - 1 do
        if arg.(i).loc = res.(j).loc then raise Exit
      done
    done;
    true
  with Exit ->
    false

(* Emit a sequence of instructions, trying to fill delay slots for branches *)

let rec emit_all i =
  match i with
    {desc = Lend} -> ()
  | {next = {desc = Lop(Icall_imm _)
                  | Lop(Iextcall(_, false))
                  | Lbranch _
                  | Lsetuptrap _ }}
    when is_one_instr i ->
      emit_instr i.next (Some i);
      emit_all i.next.next
  | {next = {desc = Lcondbranch(_, _) | Lswitch _}}
    when is_one_instr i & no_interference i.res i.next.arg ->
      emit_instr i.next (Some i);
      emit_all i.next.next
  | _ ->
      emit_instr i None;
      emit_all i.next

(* Emission of a function declaration *)

let fundecl fundecl =
  function_name := fundecl.fun_name;
  fastcode_flag := fundecl.fun_fast;
  tailrec_entry_point := new_label();
  stack_offset := 0;
  float_constants := [];
  defined_functions := StringSet.add fundecl.fun_name !defined_functions;
  range_check_trap := 0;
  `	.text\n`;
  `	.align	2\n`;
  `	.globl	{emit_symbol fundecl.fun_name}\n`;
  `{emit_symbol fundecl.fun_name}:\n`;
  let n = frame_size() in
  if !contains_calls then
    `	stwm	%r2, {emit_int n}(%r30)\n`
  else if n > 0 then
    `	ldo	{emit_int n}(%r30), %r30\n`;
  `{emit_label !tailrec_entry_point}:\n`;
  emit_all fundecl.fun_body;
  if !range_check_trap > 0 then begin
    `{emit_label !range_check_trap}:\n`;
    `	ldil	L\`{emit_symbol "array_bound_error"}, %r1\n`;
    `	ble,n	R\`{emit_symbol "array_bound_error"}(4, %r1)\n`
  end;
  List.iter emit_float_constant !float_constants

(* Emission of data *)

let emit_item = function
    Cdefine_symbol s ->
      `	.globl	{emit_symbol s}\n`;
      `{emit_symbol s}:\n`
  | Cdefine_label lbl ->
      `{emit_label (lbl + 10000)}:\n`
  | Cint8 n ->
      `	.byte	{emit_int n}\n`
  | Cint16 n ->
      `	.short	{emit_int n}\n`
  | Cint n ->
      `	.long	{emit_int n}\n`
  | Cintlit s ->
      `	.long	{emit_string s}\n`
  | Cfloat f ->
      `	.double	{emit_string f}\n`
  | Csymbol_address s ->
      `	.long	{emit_symbol s}\n`
  | Clabel_address lbl ->
      `	.long	{emit_label(lbl + 10000)}\n`
  | Cstring s ->
      let l = String.length s in
      if l = 0 then ()
      else if l < 80 then
        `	.ascii	{emit_string_literal s}\n`
      else begin
        let i = ref 0 in
        while !i < l do
          let n = min (l - !i) 80 in
          `	.ascii	{emit_string_literal(String.sub s !i n)}\n`;
          i := !i + n
        done
      end
  | Cskip n ->
      if n > 0 then `	.space	{emit_int n}\n`
  | Calign n ->
      `	.align	{emit_int(Misc.log2 n)}\n`

let data l =
  `	.data\n`;
  List.iter emit_item l

(* Beginning / end of an assembly file *)

let begin_assembly() =
  defined_functions := StringSet.empty;
  Hashtbl.clear stub_label_table;
  let lbl_begin = Compilenv.current_unit_name() ^ "_begin" in
  `	.data\n`;
  `	.globl	{emit_symbol lbl_begin}\n`;
  `{emit_symbol lbl_begin}:\n`

let end_assembly() =
  emit_stubs();
  `	.data\n`;
  let lbl_end = Compilenv.current_unit_name() ^ "_end" in
  `	.globl	{emit_symbol lbl_end}\n`;
  `{emit_symbol lbl_end}:\n`;
  `	.long	0\n`;
  let lbl = Compilenv.current_unit_name() ^ "_frametable" in
  `	.globl	{emit_symbol lbl}\n`;
  `{emit_symbol lbl}:\n`;
  `	.long	{emit_int (List.length !frame_descriptors)}\n`;
  List.iter emit_frame !frame_descriptors;
  frame_descriptors := []
