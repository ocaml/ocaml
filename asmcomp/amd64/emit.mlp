# 2 "asmcomp/amd64/emit.mlp"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Emission of Intel x86_64 assembly code *)

[@@@ocaml.warning "-40"]

open Cmm
open Arch
open Proc
open Reg
open Mach
open Linearize
open Emitaux

open X86_ast
open X86_dsl

module D = Asm_directives
module L = Linkage_name
module LR = Linkage_name.With_reloc
module Int = Numbers.Int
module TS = Target_system

(* [Branch_relaxation] is not used in this file, but is required by
   emit.mlp files for certain other targets; the reference here ensures
   that when releases are being prepared the .depend files are correct
   for all targets. *)
open! Branch_relaxation

let label_operand lbl = X86_ast.Named_thing (D.string_of_label lbl)
let symbol_operand sym = X86_ast.Named_thing (LR.to_string sym)

let mem64_rip_symbol ?ofs width sym =
  mem64_rip ?ofs width (LR.to_string sym)
let mem64_rip_label ?ofs width lbl =
  mem64_rip ?ofs width (D.string_of_label lbl)

(* Override proc.ml *)

let int_reg_name =
  [| RAX; RBX; RDI; RSI; RDX; RCX; R8; R9;
     R12; R13; R10; R11; RBP; |]

let float_reg_name = Array.init 16 (fun i -> XMM i)

let register_name r =
  if r < 100 then Reg64 (int_reg_name.(r))
  else Regf (float_reg_name.(r - 100))

let fp = Config.with_frame_pointers

let stack_offset = ref 0

(* Layout of the stack frame *)

let frame_required () =
  fp || !contains_calls || num_stack_slots.(0) > 0 || num_stack_slots.(1) > 0

let frame_size () =                     (* includes return address *)
  if frame_required() then begin
    let sz =
      (!stack_offset + 8 * (num_stack_slots.(0) + num_stack_slots.(1)) + 8
       + (if fp then 8 else 0))
    in Misc.align sz 16
  end else
    !stack_offset + 8

let slot_offset (loc : Reg.stack_location) cl =
  match loc with
  | Incoming n -> frame_size() + n
  | Local n ->
      if cl = 0
      then !stack_offset + n * 8
      else !stack_offset + (num_stack_slots.(0) + n) * 8
  | Outgoing n -> n

let record_frame = record_frame ~frame_size ~slot_offset
let record_frame_label = record_frame_label ~frame_size ~slot_offset
let bound_error_label = bound_error_label ~frame_size ~slot_offset

(* Record symbols used and defined - at the end generate extern for those
   used but not defined *)

let imp_table = L.Tbl.create 16

let reset_imp_table () = L.Tbl.clear imp_table

let get_imp_symbol s =
  match L.Tbl.find imp_table s with
  | exception Not_found ->
      let imps = L.prefix s ~with_:"__caml_imp_" in
      L.Tbl.add imp_table s imps;
      imps
  | imps -> imps

let emit_imp_table () =
  let f s imps =
    D.define_data_symbol imps;
    D.symbol (LR.no_reloc s)
  in
  D.switch_to_section Data;
  D.comment "relocation table start";
  D.align ~bytes:8;
  L.Tbl.iter f imp_table;
  D.comment "relocation table end"

let mem__imp s =
  mem64_rip_symbol QWORD (LR.no_reloc (get_imp_symbol (LR.name s)))

let rel_plt s =
  if TS.windows () && !Clflags.dlcode then mem__imp s
  else
    let use_plt =
      match TS.system (), TS.machine_width () with
      | MacOS_like, _
      | Windows MinGW, Sixty_four
      | Windows Cygwin, (Thirty_two | Sixty_four)
      | Windows Native, Sixty_four -> false
      | _, _ -> !Clflags.dlcode
    in
    symbol_operand (if use_plt then LR.plt s else s)

let emit_call s = I.call (rel_plt (LR.no_reloc s))

let emit_jump s = I.jmp (rel_plt (LR.no_reloc s))

let emit_jump_to_label lbl = I.jmp (label_operand lbl)

let load_symbol_addr s arg =
  let s = LR.no_reloc s in
  if !Clflags.dlcode then
    if TS.windows () then begin
      (* I.mov (mem__imp s) arg (\* mov __caml_imp_foo(%rip), ... *\) *)
      I.mov (symbol_operand s) arg (* movabsq $foo, ... *)
    end else
      I.mov (mem64_rip_symbol QWORD (LR.gotpcrel s)) arg
  else if !Clflags.pic_code then
    I.lea (mem64_rip_symbol NONE s) arg
  else
    I.mov (symbol_operand s) arg

let emit_Llabel fallthrough lbl =
  if not fallthrough && !fastcode_flag then D.align ~bytes:4;
  D.define_label lbl

(* Output a pseudo-register *)

let reg = function
  | { loc = Reg.Reg r } -> register_name r
  | { loc = Stack s; typ = Float } as r ->
      let ofs = slot_offset s (register_class r) in
      mem64 REAL8 ofs RSP
  | { loc = Stack s } as r ->
      let ofs = slot_offset s (register_class r) in
      mem64 QWORD ofs RSP
  | { loc = Unknown } ->
      assert false

let reg64 = function
  | { loc = Reg.Reg r } -> int_reg_name.(r)
  | _ -> assert false


let res i n = reg i.res.(n)

let arg i n = reg i.arg.(n)

(* Output a reference to the lower 8, 16 or 32 bits of a register *)

let reg_low_8_name  = Array.map (fun r -> Reg8L r) int_reg_name
let reg_low_16_name = Array.map (fun r -> Reg16 r) int_reg_name
let reg_low_32_name = Array.map (fun r -> Reg32 r) int_reg_name

let emit_subreg tbl typ r =
  match r.loc with
  | Reg.Reg r when r < 13 -> tbl.(r)
  | Stack s -> mem64 typ (slot_offset s (register_class r)) RSP
  | _ -> assert false

let arg8 i n = emit_subreg reg_low_8_name BYTE i.arg.(n)
let arg16 i n = emit_subreg reg_low_16_name WORD i.arg.(n)
let arg32 i n = emit_subreg reg_low_32_name DWORD i.arg.(n)
let arg64 i n = reg64 i.arg.(n)

let res16 i n = emit_subreg reg_low_16_name WORD i.res.(n)
let res32 i n = emit_subreg reg_low_32_name DWORD i.res.(n)

(* Output an addressing mode *)

let addressing addr typ i n =
  match addr with
  | Ibased(s, ofs) ->
      add_used_symbol s;
      mem64_rip_symbol typ (LR.no_reloc s) ~ofs
  | Iindexed d ->
      mem64 typ d (arg64 i n)
  | Iindexed2 d ->
      mem64 typ ~base:(arg64 i n) d (arg64 i (n+1))
  | Iscaled(2, d) ->
      mem64 typ ~base:(arg64 i n) d (arg64 i n)
  | Iscaled(scale, d) ->
      mem64 typ ~scale d (arg64 i n)
  | Iindexed2scaled(scale, d) ->
      mem64 typ ~scale ~base:(arg64 i n) d (arg64 i (n+1))

(* Spacetime instrumentation *)

let spacetime_uninstrumented_calls = ref Int.Map.empty

let spacetime_before_uninstrumented_call' ~node_ptr ~index =
  (* At the moment, [node_ptr] is pointing at the node for the current
     OCaml function.  Get hold of the node itself and move the pointer
     forwards, saving it into the distinguished register.  This is used
     for instrumentation of function calls (e.g. caml_call_gc and bounds
     check failures) not inserted until this stage of the compiler
     pipeline. *)
  I.mov node_ptr (reg Proc.loc_spacetime_node_hole);
  assert (index >= 2);
  I.add (int (index * 8)) (reg Proc.loc_spacetime_node_hole)

let spacetime_before_uninstrumented_call label =
  match Int.Map.find label !spacetime_uninstrumented_calls with
  | exception Not_found -> assert (not Config.spacetime)
  | (node_ptr, index) -> spacetime_before_uninstrumented_call' ~node_ptr ~index

(* Names for instructions *)

let instr_for_intop = function
  | Iadd -> I.add
  | Isub -> I.sub
  | Imul -> (fun arg1 arg2 -> I.imul arg1 (Some arg2))
  | Iand -> I.and_
  | Ior -> I.or_
  | Ixor -> I.xor
  | Ilsl -> I.sal
  | Ilsr -> I.shr
  | Iasr -> I.sar
  | _ -> assert false

let instr_for_floatop = function
  | Iaddf -> I.addsd
  | Isubf -> I.subsd
  | Imulf -> I.mulsd
  | Idivf -> I.divsd
  | _ -> assert false

let instr_for_floatarithmem = function
  | Ifloatadd -> I.addsd
  | Ifloatsub -> I.subsd
  | Ifloatmul -> I.mulsd
  | Ifloatdiv -> I.divsd

let cond = function
  | Isigned Ceq   -> E   | Isigned Cne   -> NE
  | Isigned Cle   -> LE  | Isigned Cgt   -> G
  | Isigned Clt   -> L   | Isigned Cge   -> GE
  | Iunsigned Ceq -> E   | Iunsigned Cne -> NE
  | Iunsigned Cle -> BE  | Iunsigned Cgt -> A
  | Iunsigned Clt -> B   | Iunsigned Cge -> AE

(* Output an = 0 or <> 0 test. *)

let output_test_zero arg =
  match arg.loc with
  | Reg.Reg _ -> I.test (reg arg) (reg arg)
  | _  -> I.cmp (int 0) (reg arg)

(* Output a floating-point compare and branch *)

let emit_float_test cmp neg i lbl =
  (* Effect of comisd on flags and conditional branches:
                     ZF PF CF  cond. branches taken
        unordered     1  1  1  je, jb, jbe, jp
        >             0  0  0  jne, jae, ja
        <             0  0  1  jne, jbe, jb
        =             1  0  0  je, jae, jbe.
     If FP traps are on (they are off by default),
     comisd traps on QNaN and SNaN but ucomisd traps on SNaN only.
  *)
  match (cmp, neg) with
  | (Ceq, false) | (Cne, true) ->
      let next = new_label() in
      I.ucomisd (arg i 1) (arg i 0);
      I.jp (label_operand next);  (* skip if unordered *)
      I.je lbl;                   (* branch taken if x=y *)
      D.define_label next
  | (Cne, false) | (Ceq, true) ->
      I.ucomisd (arg i 1) (arg i 0);
      I.jp lbl;                   (* branch taken if unordered *)
      I.jne lbl                   (* branch taken if x<y or x>y *)
  | (Clt, _) ->
      I.comisd (arg i 0) (arg i 1);
      if not neg then I.ja lbl    (* branch taken if y>x i.e. x<y *)
      else            I.jbe lbl   (* taken if unordered or y<=x i.e. !(x<y) *)
  | (Cle, _) ->
      I.comisd (arg i 0) (arg i 1);(* swap compare *)
      if not neg then I.jae lbl   (* branch taken if y>=x i.e. x<=y *)
      else            I.jb lbl    (* taken if unordered or y<x i.e. !(x<=y) *)
  | (Cgt, _) ->
      I.comisd (arg i 1) (arg i 0);
      if not neg then I.ja lbl    (* branch taken if x>y *)
      else            I.jbe lbl   (* taken if unordered or x<=y i.e. !(x>y) *)
  | (Cge, _) ->
      I.comisd (arg i 1) (arg i 0);(* swap compare *)
      if not neg then I.jae lbl   (* branch taken if x>=y *)
      else            I.jb lbl    (* taken if unordered or x<y i.e. !(x>=y) *)

(* Deallocate the stack frame before a return or tail call *)

let output_epilogue f =
  if frame_required() then begin
    let n = frame_size() - 8 - (if fp then 8 else 0) in
    if n <> 0
    then begin
      I.add (int n) rsp;
      D.cfi_adjust_cfa_offset ~bytes:(-n);
    end;
    if fp then I.pop rbp;
    f ();
    (* reset CFA back cause function body may continue *)
    if n <> 0
    then D.cfi_adjust_cfa_offset ~bytes:n
  end
  else
    f ()

(* Output the assembly code for an instruction *)

let emit_instr fallthrough i =
  emit_debug_info i.dbg;
  match i.desc with
  | Lend -> ()
  | Lop(Imove | Ispill | Ireload) ->
      let src = i.arg.(0) and dst = i.res.(0) in
      if src.loc <> dst.loc then
        begin match src.typ, src.loc, dst.loc with
        | Float, Reg.Reg _, Reg.Reg _ -> I.movapd (reg src) (reg dst)
        | Float, _, _ -> I.movsd (reg src) (reg dst)
        | _ -> I.mov (reg src) (reg dst)
        end
  | Lop(Iconst_int n) ->
      if Targetint.is_zero n then begin
        match i.res.(0).loc with
        | Reg _ -> I.xor (res i 0) (res i 0)
        | _     -> I.mov (int 0) (res i 0)
      end
      else
        I.mov (targetint n) (res i 0)
  | Lop(Iconst_float f) ->
      begin match f with
      | 0x0000_0000_0000_0000L ->       (* +0.0 *)
          I.xorpd (res i 0) (res i 0)
      | _ ->
          let lbl = float_constant f in
          I.movsd (mem64_rip_label NONE lbl) (res i 0)
      end
  | Lop(Iconst_symbol s) ->
      add_used_symbol s;
      load_symbol_addr s (res i 0)
  | Lop(Icall_ind { label_after; }) ->
      I.call (arg i 0);
      record_frame ~live:i.live ~raise_:false i.dbg ~label:label_after
  | Lop(Icall_imm { func; label_after; }) ->
      add_used_symbol func;
      emit_call func;
      record_frame ~live:i.live ~raise_:false i.dbg ~label:label_after
  | Lop(Itailcall_ind { label_after; }) ->
      output_epilogue begin fun () ->
        I.jmp (arg i 0);
        if Config.spacetime then begin
          record_frame ~live:Reg.Set.empty ~raise_:false i.dbg
            ~label:label_after
        end
      end
  | Lop(Itailcall_imm { func; label_after; }) ->
      begin
        if L.equal func !function_name then
          I.jmp (label_operand !tailrec_entry_point)
        else begin
          output_epilogue begin fun () ->
            add_used_symbol func;
            emit_jump func
          end
        end
      end;
      if Config.spacetime then begin
        record_frame ~live:Reg.Set.empty ~raise_:false i.dbg ~label:label_after
      end
  | Lop(Iextcall { func; alloc; label_after; }) ->
      add_used_symbol func;
      if alloc then begin
        load_symbol_addr func rax;
        emit_call L.caml_c_call;
        record_frame ~live:i.live ~raise_:false i.dbg ~label:label_after;
        if TS.win64 () then begin
          (* TODO: investigate why such a diff.
             This comes from:
            http://caml.inria.fr/cgi-bin/viewvc.cgi?view=revision&revision=12664

             If we do the same for Win64, we probably need to change
             amd64nt.asm accordingly.
          *)
          ()
        end else begin
          load_symbol_addr L.caml_young_ptr r11;
          I.mov (mem64 QWORD 0 R11) r15
        end
      end else begin
        emit_call func;
        if Config.spacetime then begin
          record_frame ~live:Reg.Set.empty ~raise_:false i.dbg
            ~label:label_after
        end
      end
  | Lop(Istackoffset n) ->
      if n < 0
      then I.add (int (-n)) rsp
      else if n > 0
      then I.sub (int n) rsp;
      if n <> 0
      then D.cfi_adjust_cfa_offset ~bytes:n;
      stack_offset := !stack_offset + n
  | Lop(Iload(chunk, addr)) ->
      let dest = res i 0 in
      begin match chunk with
      | Word_int | Word_val ->
          I.mov (addressing addr QWORD i 0) dest
      | Byte_unsigned ->
          I.movzx (addressing addr BYTE i 0) dest
      | Byte_signed ->
          I.movsx (addressing addr BYTE i 0) dest
      | Sixteen_unsigned ->
          I.movzx (addressing addr WORD i 0) dest
      | Sixteen_signed ->
          I.movsx (addressing addr WORD i 0) dest;
      | Thirtytwo_unsigned ->
          I.mov (addressing addr DWORD i 0) (res32 i 0)
      | Thirtytwo_signed ->
          I.movsxd (addressing addr DWORD i 0) dest
      | Single ->
          I.cvtss2sd (addressing addr REAL4 i 0) dest
      | Double | Double_u ->
          I.movsd (addressing addr REAL8 i 0) dest
      end
  | Lop(Istore(chunk, addr, _)) ->
      begin match chunk with
      | Word_int | Word_val ->
          I.mov (arg i 0) (addressing addr QWORD i 1)
      | Byte_unsigned | Byte_signed ->
          I.mov (arg8 i 0) (addressing addr BYTE i 1)
      | Sixteen_unsigned | Sixteen_signed ->
          I.mov (arg16 i 0) (addressing addr WORD i 1)
      | Thirtytwo_signed | Thirtytwo_unsigned ->
          I.mov (arg32 i 0) (addressing addr DWORD i 1)
      | Single ->
          I.cvtsd2ss (arg i 0) xmm15;
          I.movss xmm15 (addressing addr REAL4 i 1)
      | Double | Double_u ->
          I.movsd (arg i 0) (addressing addr REAL8 i 1)
      end
  | Lop(Ialloc { words = n; label_after_call_gc; spacetime_index; }) ->
      if !fastcode_flag then begin
        let lbl_redo = new_label() in
        D.define_label lbl_redo;
        I.sub (int n) r15;
        let spacetime_node_hole_ptr_is_in_rax =
          Config.spacetime && (i.arg.(0).loc = Reg 0)
        in
        if !Clflags.dlcode then begin
          (* When using Spacetime, %rax might be the node pointer, so we
             must take care not to clobber it.  (Whilst we can tell the
             register allocator that %rax is destroyed by Ialloc, we can't
             force that the argument (the node pointer) is not in %rax.) *)
          if spacetime_node_hole_ptr_is_in_rax then begin
            I.push rax
          end;
          load_symbol_addr L.caml_young_limit rax;
          I.cmp (mem64 QWORD 0 RAX) r15;
          if spacetime_node_hole_ptr_is_in_rax then begin
            I.pop rax  (* this does not affect the flags *)
          end
        end else
          I.cmp (mem64_rip_symbol QWORD (LR.no_reloc L.caml_young_limit)) r15;
        let lbl_call_gc = new_label() in
        let dbg =
          if not Config.spacetime then Debuginfo.none
          else i.dbg
        in
        let lbl_frame =
          record_frame_label ?label:label_after_call_gc ~live:i.live
            ~raise_:false dbg
        in
        I.jb (label_operand lbl_call_gc);
        I.lea (mem64 NONE 8 R15) (res i 0);
        if Config.spacetime then begin
          spacetime_uninstrumented_calls :=
            Int.Map.add lbl_call_gc (arg i 0, spacetime_index)
              !spacetime_uninstrumented_calls
        end;
        record_call_gc_site ~label:lbl_call_gc
          ~return_label:lbl_redo
          ~frame_label:lbl_frame
          ~stack_offset:!stack_offset
      end else begin
        if Config.spacetime then begin
          spacetime_before_uninstrumented_call' ~node_ptr:(arg i 0)
            ~index:spacetime_index;
        end;
        begin match n with
        | 16 -> emit_call L.caml_alloc1
        | 24 -> emit_call L.caml_alloc2
        | 32 -> emit_call L.caml_alloc3
        | _  ->
            I.mov (int n) rax;
            emit_call L.caml_allocN
        end;
        let label =
          record_frame_label ?label:label_after_call_gc ~live:i.live
            ~raise_:false Debuginfo.none
        in
        D.define_label label;
        I.lea (mem64 NONE 8 R15) (res i 0)
      end
  | Lop(Iintop(Icomp cmp)) ->
      I.cmp (arg i 1) (arg i 0);
      I.set (cond cmp) al;
      I.movzx al (res i 0)
  | Lop(Iintop_imm(Icomp cmp, n)) ->
      I.cmp (int n) (arg i 0);
      I.set (cond cmp) al;
      I.movzx al (res i 0)
  | Lop(Iintop (Icheckbound { label_after_error; spacetime_index; } )) ->
      let lbl =
        bound_error_label ?label:label_after_error i.dbg
          ~stack_offset:!stack_offset
      in
      if Config.spacetime then begin
        spacetime_uninstrumented_calls :=
          Int.Map.add lbl (arg i 2, spacetime_index)
            !spacetime_uninstrumented_calls
      end;
      I.cmp (arg i 1) (arg i 0);
      I.jbe (label_operand lbl)
  | Lop(Iintop_imm(Icheckbound { label_after_error; spacetime_index; }, n)) ->
      let lbl =
        bound_error_label ?label:label_after_error i.dbg
          ~stack_offset:!stack_offset
      in
      if Config.spacetime then begin
        spacetime_uninstrumented_calls :=
          Int.Map.add lbl (arg i 1, spacetime_index)
            !spacetime_uninstrumented_calls
      end;
      I.cmp (int n) (arg i 0);
      I.jbe (label_operand lbl)
  | Lop(Iintop(Idiv | Imod)) ->
      I.cqo ();
      I.idiv (arg i 1)
  | Lop(Iintop(Ilsl | Ilsr | Iasr as op)) ->
      (* We have i.arg.(0) = i.res.(0) and i.arg.(1) = %rcx *)
      instr_for_intop op cl (res i 0)
  | Lop(Iintop Imulh) ->
      I.imul (arg i 1) None
  | Lop(Iintop op) ->
      (* We have i.arg.(0) = i.res.(0) *)
      instr_for_intop op (arg i 1) (res i 0)
  | Lop(Iintop_imm(Iadd, n)) when i.arg.(0).loc <> i.res.(0).loc ->
      I.lea (mem64 NONE n (arg64 i 0)) (res i 0)
  | Lop(Iintop_imm(Iadd, 1) | Iintop_imm(Isub, -1)) ->
      I.inc (res i 0)
  | Lop(Iintop_imm(Iadd, -1) | Iintop_imm(Isub, 1)) ->
      I.dec (res i 0)
  | Lop(Iintop_imm(op, n)) ->
      (* We have i.arg.(0) = i.res.(0) *)
      instr_for_intop op (int n) (res i 0)
  | Lop(Inegf) ->
      I.xorpd (mem64_rip_symbol OWORD (LR.no_reloc L.caml_negf_mask)) (res i 0)
  | Lop(Iabsf) ->
      I.andpd (mem64_rip_symbol OWORD (LR.no_reloc L.caml_absf_mask)) (res i 0)
  | Lop(Iaddf | Isubf | Imulf | Idivf as floatop) ->
      instr_for_floatop floatop (arg i 1) (res i 0)
  | Lop(Ifloatofint) ->
      I.cvtsi2sd  (arg i 0)  (res i 0)
  | Lop(Iintoffloat) ->
      I.cvttsd2si (arg i 0) (res i 0)
  | Lop(Ispecific(Ilea addr)) ->
      I.lea (addressing addr NONE i 0) (res i 0)
  | Lop(Ispecific(Istore_int(n, addr, _))) ->
      I.mov (targetint n) (addressing addr QWORD i 0)
  | Lop(Ispecific(Ioffset_loc(n, addr))) ->
      I.add (int n) (addressing addr QWORD i 0)
  | Lop(Ispecific(Ifloatarithmem(op, addr))) ->
      instr_for_floatarithmem op (addressing addr REAL8 i 1) (res i 0)
  | Lop(Ispecific(Ibswap 16)) ->
      I.xchg ah al;
      I.movzx (res16 i 0) (res i 0)
  | Lop(Ispecific(Ibswap 32)) ->
      I.bswap (res32 i 0);
      I.movsxd (res32 i 0) (res i 0)
  | Lop(Ispecific(Ibswap 64)) ->
      I.bswap (res i 0)
  | Lop(Ispecific(Ibswap _)) ->
      assert false
  | Lop(Ispecific Isqrtf) ->
      I.sqrtsd (arg i 0) (res i 0)
  | Lop(Ispecific(Ifloatsqrtf addr)) ->
      I.sqrtsd (addressing addr REAL8 i 0) (res i 0)
  | Lreloadretaddr ->
      ()
  | Lreturn ->
      output_epilogue begin fun () ->
        I.ret ()
      end
  | Llabel lbl ->
      emit_Llabel fallthrough lbl
  | Lbranch lbl ->
      I.jmp (label_operand lbl)
  | Lcondbranch(tst, lbl) ->
      let lbl = label_operand lbl in
      begin match tst with
      | Itruetest ->
          output_test_zero i.arg.(0);
          I.jne lbl
      | Ifalsetest ->
          output_test_zero i.arg.(0);
          I.je lbl
      | Iinttest cmp ->
          I.cmp (arg i 1) (arg i 0);
          I.j (cond cmp) lbl
      | Iinttest_imm((Isigned Ceq | Isigned Cne |
                      Iunsigned Ceq | Iunsigned Cne) as cmp, 0) ->
          output_test_zero i.arg.(0);
          I.j (cond cmp) lbl
      | Iinttest_imm(cmp, n) ->
          I.cmp (int n) (arg i 0);
          I.j (cond cmp) lbl
      | Ifloattest(cmp, neg) ->
          emit_float_test cmp neg i lbl
      | Ioddtest ->
          I.test (int 1) (arg8 i 0);
          I.jne lbl
      | Ieventest ->
          I.test (int 1) (arg8 i 0);
          I.je lbl
      end
  | Lcondbranch3(lbl0, lbl1, lbl2) ->
      I.cmp (int 1) (arg i 0);
      begin match lbl0 with
      | None -> ()
      | Some lbl -> I.jb (label_operand lbl)
      end;
      begin match lbl1 with
      | None -> ()
      | Some lbl -> I.je (label_operand lbl)
      end;
      begin match lbl2 with
      | None -> ()
      | Some lbl -> I.jg (label_operand lbl)
      end
  | Lswitch jumptbl ->
      let lbl = new_label () in
      (* rax and rdx are clobbered by the Lswitch,
         meaning that no variable that is live across the Lswitch
         is assigned to rax or rdx.  However, the argument to Lswitch
         can still be assigned to one of these two registers, so
         we must be careful not to clobber it before use. *)
      let (tmp1, tmp2) =
        if i.arg.(0).loc = Reg 0 (* rax *)
        then (phys_reg 4 (*rdx*), phys_reg 0 (*rax*))
        else (phys_reg 0 (*rax*), phys_reg 4 (*rdx*)) in

      I.lea (mem64_rip_label NONE lbl) (reg tmp1);
      I.movsxd (mem64 DWORD 0 (arg64 i 0) ~scale:4 ~base:(reg64 tmp1))
               (reg tmp2);
      I.add (reg tmp2) (reg tmp1);
      I.jmp (reg tmp1);

      D.switch_to_section Jump_tables;
      D.align ~bytes:4;
      D.define_label lbl;
      for i = 0 to Array.length jumptbl - 1 do
        D.between_labels_32bit ~upper:jumptbl.(i) ~lower:lbl
      done;
      D.switch_to_section Text
  | Lsetuptrap lbl ->
      I.call (label_operand lbl)
  | Lpushtrap ->
      D.cfi_adjust_cfa_offset ~bytes:8;
      I.push r14;
      D.cfi_adjust_cfa_offset ~bytes:8;
      I.mov rsp r14;
      stack_offset := !stack_offset + 16
  | Lpoptrap ->
      I.pop r14;
      D.cfi_adjust_cfa_offset ~bytes:(-8);
      I.add (int 8) rsp;
      D.cfi_adjust_cfa_offset ~bytes:(-8);
      stack_offset := !stack_offset - 16
  | Lraise k ->
      (* No Spacetime instrumentation is required for [caml_raise_exn] and
         [caml_reraise_exn].  The only function called that might affect the
         trie is [caml_stash_backtrace], and it does not. *)
      begin match k with
      | Cmm.Raise_withtrace ->
          emit_call L.caml_raise_exn;
          record_frame ~live:Reg.Set.empty ~raise_:true i.dbg
      | Cmm.Raise_notrace ->
          I.mov r14 rsp;
          I.pop r14;
          I.ret ()
      end

let emit_all ~fun_body =
  let rec emit_all fallthrough i =
    match i.desc with
    | Lend -> ()
    | _ ->
        emit_instr fallthrough i;
        emit_all (Linearize.has_fallthrough i.desc) i.next
  in
  emit_all true fun_body;
  if not (frame_required ()) then 0
  else frame_size() - 8 - (if fp then 8 else 0)

(* Emission of the profiling prelude *)

let emit_profile () =
  match TS.system () with
  | GNU | Linux _ ->
    (* mcount preserves rax, rcx, rdx, rsi, rdi, r8, r9 explicitly
       and rbx, rbp, r12-r15 like all C functions.  This includes
       all the registers used for argument passing, so we don't
       need to preserve other regs.  We do need to initialize rbp
       like mcount expects it, though. *)
    I.push r10;
    if not fp then I.mov rsp rbp;
    (* No Spacetime instrumentation needed: [mcount] cannot call anything
       OCaml-related. *)
    emit_call L.mcount;
    I.pop r10
  | _ -> ()

(* Emission of a function declaration *)

let prepare _fundecl =
  stack_offset := 0;
  if fp then begin
    I.push rbp;
    D.cfi_adjust_cfa_offset ~bytes:8;
    I.mov rsp rbp;
  end;
  if !Clflags.gprofile then emit_profile();
  if frame_required() then begin
    let n = frame_size() - 8 - (if fp then 8 else 0) in
    if n <> 0
    then begin
      I.sub (int n) rsp;
      D.cfi_adjust_cfa_offset ~bytes:n;
    end;
  end

let fundecl decl =
  Emitaux.fundecl decl
    ~prepare
    ~emit_all
    ~emit_call
    ~emit_jump_to_label
    ~spacetime_before_uninstrumented_call
    ~alignment_in_bytes:16
    ~emit_numeric_constants:false

(* Beginning / end of an assembly file *)

let begin_assembly() =
  spacetime_uninstrumented_calls := Int.Map.empty;
  X86_proc.reset_asm_code ();
  Asm_directives.initialize ~emit:(fun directive ->
    X86_proc.directive (Directive directive));
  reset_imp_table();
  Emitaux.begin_assembly ();
  if TS.macos_like () then begin
    (* suppress "ld warning: atom sorting error" *)
    D.switch_to_section Text;
    I.nop ()
  end;
  if TS.win64 () then begin
    let extrn sym width = X86_dsl.D.extrn (L.to_string sym) width in
    extrn L.caml_young_ptr QWORD;
    extrn L.caml_young_limit QWORD;
    extrn L.caml_exception_pointer QWORD;
    extrn L.caml_call_gc NEAR;
    extrn L.caml_c_call NEAR;
    extrn L.caml_allocN NEAR;
    extrn L.caml_alloc1 NEAR;
    extrn L.caml_alloc2 NEAR;
    extrn L.caml_alloc3 NEAR;
    extrn L.caml_ml_array_bound_error NEAR;
    extrn L.caml_raise_exn NEAR
  end;
  if !Clflags.dlcode || TS.win64 () then begin
    (* from amd64.S; could emit these constants on demand *)
    D.switch_to_section Sixteen_byte_literals;
    D.align ~bytes:16;
    D.define_data_symbol L.caml_negf_mask;
    D.int64 0x8000000000000000L;
    D.int64 0L;
    D.align ~bytes:16;
    D.define_data_symbol L.caml_absf_mask;
    D.int64 0x7FFFFFFFFFFFFFFFL;
    D.int64 0xFFFFFFFFFFFFFFFFL
  end

let end_assembly () =
  emit_imp_table();
  if TS.macos_like () then begin
    (* suppress "ld warning: atom sorting error" *)
    D.switch_to_section Text;
    I.nop ()
  end;
  Emitaux.end_assembly ~emit_numeric_constants:true ();
  if TS.win64 () then begin
    D.comment "External functions";
    L.Set.iter (fun s ->
        if not (L.Set.mem s (symbols_defined ())) then
          X86_dsl.D.extrn (L.to_string s) NEAR)
      (symbols_used ())
  end;
  let asm =
    match !Emitaux.create_asm_file, TS.assembler () with
    | true, MASM -> Some (X86_masm.generate_asm !output_channel)
    | true, (MacOS | GAS_like) -> Some (X86_gas.generate_asm !output_channel)
    | false, _ -> None
  in
  X86_proc.generate_code asm
