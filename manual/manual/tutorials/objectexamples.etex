\chapter{Objects in OCaml}
\label{c:objectexamples}
\pdfchapterfold{-15}{Tutorial: Objects in OCaml}
%HEVEA\cutname{objectexamples.html}
{\it (Chapter written by Jérôme Vouillon, Didier Rémy and Jacques Garrigue)}

\bigskip

\noindent This chapter gives an overview of the object-oriented features of
OCaml. Note that the relation between object, class and type
in OCaml is very different from that in mainstream
object-oriented languages like Java or C++, so that you should not
assume that similar keywords mean the same thing.

\begin{htmlonly}

\ref{ss:classes-and-objects} Classes and objects \\
\ref{ss:immediate-objects} Immediate objects \\
\ref{ss:reference-to-self} Reference to self \\
\ref{ss:initializers} Initializers \\
\ref{ss:virtual-methods} Virtual methods \\
\ref{ss:private-methods} Private methods \\
\ref{ss:class-interfaces} Class interfaces \\
\ref{ss:inheritance} Inheritance \\
\ref{ss:multiple-inheritance} Multiple inheritance \\
\ref{ss:parameterized-classes} Parameterized classes \\
\ref{ss:polymorphic-methods} Polymorphic methods \\
\ref{ss:using-coercions} Using coercions \\
\ref{ss:functional-objects} Functional objects \\
\ref{ss:cloning-objects} Cloning objects \\
\ref{ss:recursive-classes} Recursive classes \\
\ref{ss:binary-methods} Binary methods \\
\ref{ss:friends} Friends \\

%%\ref{s:advanced-examples} {\bf Advanced examples}
%%
%%\ref{ss:bank-accounts} An extended example of bank accounts \\
%%\ref{ss:modules-as-classes} Simple modules as classes:
%%  \ref{module:string} Strings
%%  \ref{module:stack} Stacks
%%  \ref{module:hashtbl} Hash tables
%%  \ref{module:set} Sets \\
%%\ref{ss:subject-observer} The subject/observer pattern \\

\end{htmlonly}

\section{Classes and objects}
\pdfsection{Classes and objects}
\label{ss:classes-and-objects}

The class "point" below defines one instance variable "x" and two methods
"get_x" and "move". The initial value of the instance variable is "0".
The variable "x" is declared mutable, so the method "move" can change
its value.
\begin{caml_example}
class point =
  object
    val mutable x = 0
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}

We now create a new point "p", instance of the "point" class.
\begin{caml_example}
let p = new point;;
\end{caml_example}
Note that the type of "p" is "point". This is an abbreviation
automatically defined by the class definition above. It stands for the
object type "<get_x : int; move : int -> unit>", listing the methods
of class "point" along with their types.

We now invoke some methods to "p":
\begin{caml_example}
p#get_x;;
p#move 3;;
p#get_x;;
\end{caml_example}

The evaluation of the body of a class only takes place at object
creation time.  Therefore, in the following example, the instance
variable "x" is initialized to different values for two different
objects.
\begin{caml_example}
let x0 = ref 0;;
class point =
  object
    val mutable x = incr x0; !x0
    method get_x = x
    method move d = x <- x + d
  end;;
new point#get_x;;
new point#get_x;;
\end{caml_example}

The class "point" can also be abstracted over the initial values of
the "x" coordinate.
\begin{caml_example}
class point = fun x_init ->
  object
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}
Like in function definitions, the definition above can be
abbreviated as:
\begin{caml_example}
class point x_init =
  object
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}
An instance of the class "point" is now a function that expects an
initial parameter to create a point object:
\begin{caml_example}
new point;;
let p = new point 7;;
\end{caml_example}
The parameter "x_init" is, of course, visible in the whole body of the
definition, including methods. For instance, the method "get_offset"
in the class below returns the position of the object relative to its
initial position.
\begin{caml_example}
class point x_init =
  object
    val mutable x = x_init
    method get_x = x
    method get_offset = x - x_init
    method move d = x <- x + d
  end;;
\end{caml_example}
%Instance variables can only be used inside methods. For instance it would
%not be possible to define
%\begin{caml_example}
%class point x_init =
%  object
%    val mutable x = x_init
%    val origin = x
%    method get_offset = x - origin
%    method move d = x <- x + d
%  end;;
%\end{caml_example}
Expressions can be evaluated and bound before defining the object body
of the class. This is useful to enforce invariants. For instance,
points can be automatically adjusted to the nearest point on a grid,
as follows:
\begin{caml_example}
class adjusted_point x_init =
  let origin = (x_init / 10) * 10 in
  object
    val mutable x = origin
    method get_x = x
    method get_offset = x - origin
    method move d = x <- x + d
  end;;
\end{caml_example}
(One could also raise an exception if the "x_init" coordinate is not
on the grid.) In fact, the same effect could here be obtained by
calling the definition of class "point" with the value of the
"origin".
\begin{caml_example}
class adjusted_point x_init =  point ((x_init / 10) * 10);;
\end{caml_example}
An alternate solution would have been to define the adjustment in
a special allocation function:
\begin{caml_example}
let new_adjusted_point x_init = new point ((x_init / 10) * 10);;
\end{caml_example}
However, the former pattern is generally more appropriate, since
the code for adjustment is part of the definition of the class and will be
inherited.

This ability provides class constructors as can be found in other
languages. Several constructors can be defined this way to build objects of
the same class but with different initialization patterns; an
alternative is to use initializers, as described below in section
\ref{ss:initializers}.

\section{Immediate objects}
\pdfsection{Immediate objects}
\label{ss:immediate-objects}

There is another, more direct way to create an object: create it
without going through a class.

The syntax is exactly the same as for class expressions, but the
result is a single object rather than a class. All the constructs
described in the rest of this section also apply to immediate objects.
\begin{caml_example}
let p =
  object
    val mutable x = 0
    method get_x = x
    method move d = x <- x + d
  end;;
p#get_x;;
p#move 3;;
p#get_x;;
\end{caml_example}

Unlike classes, which cannot be defined inside an expression,
immediate objects can appear anywhere, using variables from their
environment.
\begin{caml_example}
let minmax x y =
  if x < y then object method min = x method max = y end
  else object method min = y method max = x end;;
\end{caml_example}

Immediate objects have two weaknesses compared to classes: their types
are not abbreviated, and you cannot inherit from them. But these two
weaknesses can be advantages in some situations, as we will see
in sections \ref{ss:reference-to-self} and \ref{ss:parameterized-classes}.

\section{Reference to self}
\pdfsection{Reference to self}
\label{ss:reference-to-self}

A method or an initializer can send messages to self (that is,
the current object).  For that, self must be explicitly bound, here to
the variable "s" ("s" could be any identifier, even though we will
often choose the name "self".)
\begin{caml_example}
class printable_point x_init =
  object (s)
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
    method print = print_int s#get_x
  end;;
let p = new printable_point 7;;
p#print;;
\end{caml_example}
Dynamically, the variable "s" is bound at the invocation of a method.  In
particular, when the class "printable_point" is inherited, the variable
"s" will be correctly bound to the object of the subclass.

A common problem with self is that, as its type may be extended in
subclasses, you cannot fix it in advance. Here is a simple example.
\begin{caml_example}
let ints = ref [];;
class my_int =
  object (self)
    method n = 1
    method register = ints := self :: !ints
  end [@@expect error];;
\end{caml_example}
You can ignore the first two lines of the error message. What matters
is the last one: putting self into an external reference would make it
impossible to extend it through inheritance.
We will see in section \ref{ss:using-coercions} a workaround to this
problem.
Note however that, since immediate objects are not extensible, the
problem does not occur with them.
\begin{caml_example}
let my_int =
  object (self)
    method n = 1
    method register = ints := self :: !ints
  end;;
\end{caml_example}

\section{Initializers}
\pdfsection{Initializers}
\label{ss:initializers}

Let-bindings within class definitions are evaluated before the object
is constructed. It is also possible to evaluate an expression
immediately after the object has been built. Such code is written as
an anonymous hidden method called an initializer. Therefore, it can
access self and the instance variables.
\begin{caml_example}
class printable_point x_init =
  let origin = (x_init / 10) * 10 in
  object (self)
    val mutable x = origin
    method get_x = x
    method move d = x <- x + d
    method print = print_int self#get_x
    initializer print_string "new point at "; self#print; print_newline ()
  end;;
let p = new printable_point 17;;
\end{caml_example}
Initializers cannot be overridden. On the contrary, all initializers are
evaluated sequentially.
Initializers are particularly useful to enforce invariants.
Another example can be seen in section \ref{ss:bank-accounts}.


\section{Virtual methods}
\pdfsection{Virtual methods and variables}
\label{ss:virtual-methods}

It is possible to declare a method without actually defining it, using
the keyword "virtual".  This method will be provided later in
subclasses. A class containing virtual methods must be flagged
"virtual", and cannot be instantiated (that is, no object of this class
can be created). It still defines type abbreviations (treating virtual methods
as other methods.)
\begin{caml_example}
class virtual abstract_point x_init =
  object (self)
    method virtual get_x : int
    method get_offset = self#get_x - x_init
    method virtual move : int -> unit
  end;;
class point x_init =
  object
    inherit abstract_point x_init
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}

Instance variables can also be declared as virtual, with the same effect
as with methods.
\begin{caml_example}
class virtual abstract_point2 =
  object
    val mutable virtual x : int
    method move d = x <- x + d
  end;;
class point2 x_init =
  object
    inherit abstract_point2
    val mutable x = x_init
    method get_offset = x - x_init
  end;;
\end{caml_example}

\section{Private methods}
\pdfsection{Private methods}
\label{ss:private-methods}

Private methods are methods that do not appear in object interfaces.
They can only be invoked from other methods of the same object.
\begin{caml_example}
class restricted_point x_init =
  object (self)
    val mutable x = x_init
    method get_x = x
    method private move d = x <- x + d
    method bump = self#move 1
  end;;
let p = new restricted_point 0;;
p#move 10 [@@expect error] ;;
p#bump;;
\end{caml_example}
Note that this is not the same thing as private and protected methods
in Java or C++, which can be called from other objects of the same
class. This is a direct consequence of the independence between types
and classes in OCaml: two unrelated classes may produce
objects of the same type, and there is no way at the type level to
ensure that an object comes from a specific class. However a possible
encoding of friend methods is given in section \ref{ss:friends}.

Private methods are inherited (they are by default visible in subclasses),
unless they are hidden by signature matching, as described below.

Private methods can be made public in a subclass.
\begin{caml_example}
class point_again x =
  object (self)
    inherit restricted_point x
    method virtual move : _
  end;;
\end{caml_example}
The annotation "virtual" here is only used to mention a method without
providing its definition. Since we didn't add the "private"
annotation, this makes the method public, keeping the original
definition.

An alternative definition is
\begin{caml_example}
class point_again x =
  object (self : < move : _; ..> )
    inherit restricted_point x
  end;;
\end{caml_example}
The constraint on self's type is requiring a public "move" method, and
this is sufficient to override "private".

One could think that a private method should remain private in a subclass.
However, since the method is visible in a subclass, it is always possible
to pick its code and define a method of the same name that runs that
code, so yet another (heavier) solution would be:
\begin{caml_example}
class point_again x =
  object
    inherit restricted_point x as super
    method move = super#move
  end;;
\end{caml_example}

Of course, private methods can also be virtual. Then, the keywords must
appear in this order "method private virtual".

\section{Class interfaces}
\pdfsection{Class interfaces}
\label{ss:class-interfaces}


%XXX Differentiate class type and class interface ?

Class interfaces are inferred from class definitions.  They may also
be defined directly and used to restrict the type of a class.  Like class
declarations, they also define a new type abbreviation.
\begin{caml_example}
class type restricted_point_type =
  object
    method get_x : int
    method bump : unit
end;;
fun (x : restricted_point_type) -> x;;
\end{caml_example}
In addition to program documentation, class interfaces can be used to
constrain the type of a class. Both concrete instance variables and concrete
private methods can be hidden by a class type constraint. Public
methods and virtual members, however, cannot.
\begin{caml_example}
class restricted_point' x = (restricted_point x : restricted_point_type);;
\end{caml_example}
Or, equivalently:
\begin{caml_example}
class restricted_point' = (restricted_point : int -> restricted_point_type);;
\end{caml_example}
The interface of a class can also be specified in a module
signature, and used to restrict the inferred signature of a module.
\begin{caml_example}
module type POINT = sig
  class restricted_point' : int ->
    object
      method get_x : int
      method bump : unit
    end
end;;
module Point : POINT = struct
  class restricted_point' = restricted_point
end;;
\end{caml_example}

\section{Inheritance}
\pdfsection{Inheritance}
\label{ss:inheritance}

We illustrate inheritance by defining a class of colored points that
inherits from the class of points.  This class has all instance
variables and all methods of class "point", plus a new instance
variable "c" and a new method "color".
\begin{caml_example}
class colored_point x (c : string) =
  object
    inherit point x
    val c = c
    method color = c
  end;;
let p' = new colored_point 5 "red";;
p'#get_x, p'#color;;
\end{caml_example}
A point and a colored point have incompatible types, since a point has
no method "color". However, the function "get_x" below is a generic
function applying method "get_x" to any object "p" that has this
method (and possibly some others, which are represented by an ellipsis
in the type). Thus, it applies to both points and colored points.
\begin{caml_example}
let get_succ_x p = p#get_x + 1;;
get_succ_x p + get_succ_x p';;
\end{caml_example}
Methods need not be declared previously, as shown by the example:
\begin{caml_example}
let set_x p = p#set_x;;
let incr p = set_x p (get_succ_x p);;
\end{caml_example}

\section{Multiple inheritance}
\pdfsection{Multiple inheritance}
\label{ss:multiple-inheritance}

Multiple inheritance is allowed. Only the last definition of a method
is kept: the redefinition in a subclass of a method that was visible in
the parent class overrides the definition in the parent class.
Previous definitions of a method can be reused by binding the related
ancestor. Below, "super" is bound to the ancestor "printable_point".
The name "super" is a pseudo value identifier that can only be used to
invoke a super-class method, as in "super#print".
\begin{caml_example}
class printable_colored_point y c =
  object (self)
    val c = c
    method color = c
    inherit printable_point y as super
    method print =
      print_string "(";
      super#print;
      print_string ", ";
      print_string (self#color);
      print_string ")"
  end;;
let p' = new printable_colored_point 17 "red";;
p'#print;;
\end{caml_example}
A private method that has been hidden in the parent class is no longer
visible, and is thus not overridden. Since initializers are treated as
private methods, all initializers along the class hierarchy are evaluated,
in the order they are introduced.

\section{Parameterized classes}
\pdfsection{Parameterized classes}
\label{ss:parameterized-classes}

Reference cells can be implemented as objects.
The naive definition fails to typecheck:
\begin{caml_example}[error]
class oref x_init =
  object
    val mutable x = x_init
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
The reason is that at least one of the methods has a polymorphic type
(here, the type of the value stored in the reference cell), thus
either the class should be parametric, or the method type should be
constrained to a monomorphic type.  A monomorphic instance of the class could
be defined by:
\begin{caml_example}
class oref (x_init:int) =
  object
    val mutable x = x_init
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
Note that since immediate objects do not define a class type, they have
no such restriction.
\begin{caml_example}
let new_oref x_init =
  object
    val mutable x = x_init
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
On the other hand, a class for polymorphic references must explicitly
list the type parameters in its declaration. Class type parameters are
listed between "[" and "]". The type parameters must also be
bound somewhere in the class body by a type constraint.
\begin{caml_example}
class ['a] oref x_init =
  object
    val mutable x = (x_init : 'a)
    method get = x
    method set y = x <- y
  end;;
let r = new oref 1 in r#set 2; (r#get);;
\end{caml_example}
The type parameter in the declaration may actually be constrained in the
body of the class definition. In the class type, the actual value of
the type parameter is displayed in the "constraint" clause.
\begin{caml_example}
class ['a] oref_succ (x_init:'a) =
  object
    val mutable x = x_init + 1
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
Let us consider a more complex example: define a circle, whose center
may be any kind of point.  We put an additional type
constraint in method "move", since no free variables must remain
unaccounted for by the class type parameters.
\begin{caml_example}
class ['a] circle (c : 'a) =
  object
    val mutable center = c
    method center = center
    method set_center c = center <- c
    method move = (center#move : int -> unit)
  end;;
\end{caml_example}
An alternate definition of "circle", using a "constraint" clause in
the class definition, is shown below. The type "#point" used below in
the "constraint" clause is an abbreviation produced by the definition
of class "point". This abbreviation unifies with the type of any
object belonging to a subclass of class "point". It actually expands to
"< get_x : int; move : int -> unit; .. >". This leads to the following
alternate definition of "circle", which has slightly stronger
constraints on its argument, as we now expect "center" to have a
method "get_x".
\begin{caml_example}
class ['a] circle (c : 'a) =
  object
    constraint 'a = #point
    val mutable center = c
    method center = center
    method set_center c = center <- c
    method move = center#move
  end;;
\end{caml_example}
The class "colored_circle" is a specialized version of class
"circle" that requires the type of the center to unify with
"#colored_point", and adds a method "color". Note that when specializing a
parameterized class, the instance of type parameter must always be
explicitly given. It is again written between "[" and "]".
\begin{caml_example}
class ['a] colored_circle c =
  object
    constraint 'a = #colored_point
    inherit ['a] circle c
    method color = center#color
  end;;
\end{caml_example}

\section{Polymorphic methods}
\pdfsection{Polymorphic methods}
\label{ss:polymorphic-methods}

While parameterized classes may be polymorphic in their contents, they
are not enough to allow polymorphism of method use.

A classical example is defining an iterator.
\begin{caml_example}
List.fold_left;;
class ['a] intlist (l : int list) =
  object
    method empty = (l = [])
    method fold f (accu : 'a) = List.fold_left f accu l
  end;;
\end{caml_example}
At first look, we seem to have a polymorphic iterator, however this
does not work in practice.
\begin{caml_example}
let l = new intlist [1; 2; 3];;
l#fold (fun x y -> x+y) 0;;
l;;
l#fold (fun s x -> s ^ string_of_int x ^ " ") "" [@@expect error];;
\end{caml_example}
Our iterator works, as shows its first use for summation. However,
since objects themselves are not polymorphic (only their constructors
are), using the "fold" method fixes its type for this individual object.
Our next attempt to use it as a string iterator fails.

The problem here is that quantification was wrongly located: it is
not the class we want to be polymorphic, but the "fold" method.
This can be achieved by giving an explicitly polymorphic type in the
method definition.
\begin{caml_example}
class intlist (l : int list) =
  object
    method empty = (l = [])
    method fold : 'a. ('a -> int -> 'a) -> 'a -> 'a =
      fun f accu -> List.fold_left f accu l
  end;;
let l = new intlist [1; 2; 3];;
l#fold (fun x y -> x+y) 0;;
l#fold (fun s x -> s ^ string_of_int x ^ " ") "";;
\end{caml_example}
As you can see in the class type shown by the compiler, while
polymorphic method types must be fully explicit in class definitions
(appearing immediately after the method name), quantified type
variables can be left implicit in class descriptions. Why require types
to be explicit? The problem is that "(int -> int -> int) -> int ->
int" would also be a valid type for "fold", and it happens to be
incompatible with the polymorphic type we gave (automatic
instantiation only works for toplevel types variables, not for inner
quantifiers, where it becomes an undecidable problem.) So the compiler
cannot choose between those two types, and must be helped.

However, the type can be completely omitted in the class definition if
it is already known, through inheritance or type constraints on self.
Here is an example of method overriding.
\begin{caml_example*}
class intlist_rev l =
  object
    inherit intlist l
    method fold f accu = List.fold_left f accu (List.rev l)
  end;;
\end{caml_example*}
The following idiom separates description and definition.
\begin{caml_example*}
class type ['a] iterator =
  object method fold : ('b -> 'a -> 'b) -> 'b -> 'b end;;
class intlist l =
  object (self : int #iterator)
    method empty = (l = [])
    method fold f accu = List.fold_left f accu l
  end;;
\end{caml_example*}
Note here the "(self : int #iterator)" idiom, which ensures that this
object implements the interface "iterator".

Polymorphic methods are called in exactly the same way as normal
methods, but you should be aware of some limitations of type
inference.  Namely, a polymorphic method can only be called if its
type is known at the call site.  Otherwise, the method will be assumed
to be monomorphic, and given an incompatible type.
\begin{caml_example}
let sum lst = lst#fold (fun x y -> x+y) 0;;
sum l [@@expect error];;
\end{caml_example}
The workaround is easy: you should put a type constraint on the
parameter.
\begin{caml_example}
let sum (lst : _ #iterator) = lst#fold (fun x y -> x+y) 0;;
\end{caml_example}
Of course the constraint may also be an explicit method type.
Only occurences of quantified variables are required.
\begin{caml_example}
let sum lst =
  (lst : < fold : 'a. ('a -> _ -> 'a) -> 'a -> 'a; .. >)#fold (+) 0;;
\end{caml_example}

Another use of polymorphic methods is to allow some form of implicit
subtyping in method arguments. We have already seen in section
\ref{ss:inheritance} how some functions may be polymorphic in the
class of their argument. This can be extended to methods.
\begin{caml_example}
class type point0 = object method get_x : int end;;
class distance_point x =
  object
    inherit point x
    method distance : 'a. (#point0 as 'a) -> int =
      fun other -> abs (other#get_x - x)
  end;;
let p = new distance_point 3 in
(p#distance (new point 8), p#distance (new colored_point 1 "blue"));;
\end{caml_example}
Note here the special syntax "(#point0 as 'a)" we have to use to
quantify the extensible part of "#point0". As for the variable binder,
it can be omitted in class specifications. If you want polymorphism
inside object field it must be quantified independently.
\begin{caml_example}
class multi_poly =
  object
    method m1 : 'a. (< n1 : 'b. 'b -> 'b; .. > as 'a) -> _ =
      fun o -> o#n1 true, o#n1 "hello"
    method m2 : 'a 'b. (< n2 : 'b -> bool; .. > as 'a) -> 'b -> _ =
      fun o x -> o#n2 x
  end;;
\end{caml_example}
In method "m1", "o" must be an object with at least a method "n1",
itself polymorphic.  In method "m2", the argument of "n2" and "x" must
have the same type, which is quantified at the same level as "'a".

\section{Using coercions}
\pdfsection{Using coercions}
\label{ss:using-coercions}

Subtyping is never implicit.  There are, however, two ways to perform
subtyping.  The most general construction is fully explicit: both the
domain and the codomain of the type coercion must be given.

We have seen that points and colored points have incompatible types.
For instance, they cannot be mixed in the same list. However, a
colored point can be coerced to a point, hiding its "color" method:
\begin{caml_example}
let colored_point_to_point cp = (cp : colored_point :> point);;
let p = new point 3 and q = new colored_point 4 "blue";;
let l = [p; (colored_point_to_point q)];;
\end{caml_example}
An object of type "t" can be seen as an object of type "t'"
only if "t" is a subtype of "t'". For instance, a point cannot be
seen as a colored point.
\begin{caml_example}[error]
(p : point :> colored_point);;
\end{caml_example}
Indeed, narrowing coercions without runtime checks would be unsafe.
Runtime type checks might raise exceptions, and they would require
the presence of type information at runtime, which is not the case in
the OCaml system.
For these reasons, there is no such operation available in the language.

Be aware that subtyping and inheritance are not related.  Inheritance is a
syntactic relation between classes while subtyping is a semantic relation
between types.  For instance, the class of colored points could have been
defined directly, without inheriting from the class of points; the type of
colored points would remain unchanged and thus still be a subtype of
points.
% Conversely, the class "int_comparable" inherits from class
%"comparable", but type "int_comparable" is not a subtype of "comparable".
%\begin{caml_example}
%function x -> (x : int_comparable :> comparable);;
%\end{caml_example}

The domain of a coercion can often be omitted. For instance, one can
define:
\begin{caml_example}
let to_point cp = (cp :> point);;
\end{caml_example}
In this case, the function "colored_point_to_point" is an instance of the
function "to_point". This is not always true, however. The fully
explicit coercion  is more precise and is sometimes  unavoidable.
Consider, for example, the following class:
\begin{caml_example}
class c0 = object method m = {< >} method n = 0 end;;
\end{caml_example}
The object type "c0" is an abbreviation for "<m : 'a; n : int> as 'a".
Consider now the type declaration:
\begin{caml_example}
class type c1 =  object method m : c1 end;;
\end{caml_example}
The object type "c1" is an abbreviation for the type "<m : 'a> as 'a".
The coercion from an object of type "c0" to an object of type "c1" is
correct:
\begin{caml_example}
fun (x:c0) -> (x : c0 :> c1);;
\end{caml_example}
%%% FIXME come up with a better example.
% However, the domain of the coercion cannot be omitted here:
% \begin{caml_example}
% fun (x:c0) -> (x :> c1);;
% \end{caml_example}
However, the domain of the coercion cannot always be omitted.
In that case, the solution is to use the explicit form.
%
Sometimes, a change in the class-type definition can also solve the problem
\begin{caml_example}
class type c2 = object ('a) method m : 'a end;;
fun (x:c0) -> (x :> c2);;
\end{caml_example}
While class types "c1" and "c2" are different, both object types
"c1" and "c2" expand to the same object type (same method names and types).
Yet, when the domain of a coercion is left implicit and its co-domain
is an abbreviation of a known class type, then the class type, rather
than the object type, is used to derive the coercion function. This
allows leaving the domain implicit in most cases when coercing form a
subclass to its superclass.
%
The type of a coercion can always be seen as below:
\begin{caml_example}
let to_c1 x = (x :> c1);;
let to_c2 x = (x :> c2);;
\end{caml_example}
Note the difference between these two coercions: in the case of "to_c2",
the type
"#c2 = < m : 'a; .. > as 'a" is polymorphically recursive (according
to the explicit recursion in the class type of "c2"); hence the
success of applying this coercion to an object of class "c0".
On the other hand, in the first case, "c1" was only expanded and
unrolled twice to obtain "< m : < m : c1; .. >; .. >" (remember "#c1 =
< m : c1; .. >"), without introducing recursion.
You may also note that the type of "to_c2" is "#c2 -> c2" while
the type of "to_c1" is more general than "#c1 -> c1". This is not always true,
since there are class types for which some instances of "#c" are not subtypes
of "c", as explained in section~\ref{ss:binary-methods}. Yet, for
parameterless classes the coercion "(_ :> c)" is always more general than
"(_ : #c :> c)".
%If a class type exposes the type of self through one of its parameters, this
%is no longer true. Here is a counter-example.
%\begin{caml_example}
%class type ['a] c = object ('a) method m : 'a end;;
%let to_c x = (x :> _ c);;
%\end{caml_example}


A common problem may occur when one tries to define a coercion to a
class "c" while defining class "c". The problem is due to the type
abbreviation not being completely defined yet, and so its subtypes are not
clearly known.  Then, a coercion "(_ :> c)" or "(_ : #c :> c)" is taken to be
the identity function, as in
\begin{caml_example}
function x -> (x :> 'a);;
\end{caml_example}
As a consequence, if the coercion is applied to "self", as in the
following example, the type of "self" is unified with the closed type
"c" (a closed object type is an object type without ellipsis).  This
would constrain the type of self be closed and is thus rejected.
Indeed, the type of self cannot be closed: this would prevent any
further extension of the class. Therefore, a type error is generated
when the unification of this type with another type would result in a
closed object type.
\begin{caml_example}[error]
class c = object method m = 1 end
and d = object (self)
  inherit c
  method n = 2
  method as_c = (self :> c)
end;;
\end{caml_example}
However, the most common instance of this problem, coercing self to
its current class, is detected as a special case by the type checker,
and properly typed.
\begin{caml_example}
class c = object (self) method m = (self :> c) end;;
\end{caml_example}
This allows the following idiom, keeping a list of all objects
belonging to a class or its subclasses:
\begin{caml_example}
let all_c = ref [];;
class c (m : int) =
  object (self)
    method m = m
    initializer all_c := (self :> c) :: !all_c
  end;;
\end{caml_example}
This idiom can in turn be used to retrieve an object whose type has
been weakened:
\begin{caml_example}
let rec lookup_obj obj = function [] -> raise Not_found
  | obj' :: l ->
     if (obj :> < >) = (obj' :> < >) then obj' else lookup_obj obj l ;;
let lookup_c obj = lookup_obj obj !all_c;;
\end{caml_example}
The type "< m : int >" we see here is just the expansion of "c", due
to the use of a reference; we have succeeded in getting back an object
of type "c".

\medskip
The previous coercion problem can often be avoided by first
defining the abbreviation, using a class type:
\begin{caml_example}
class type c' = object method m : int end;;
class c : c' = object method m = 1 end
and d = object (self)
  inherit c
  method n = 2
  method as_c = (self :> c')
end;;
\end{caml_example}
It is also possible to use a virtual class. Inheriting from this class
simultaneously forces all methods of "c" to have the same
type as the methods of "c'".
\begin{caml_example}
class virtual c' = object method virtual m : int end;;
class c = object (self) inherit c' method m = 1 end;;
\end{caml_example}
One could think of defining the type abbreviation directly:
\begin{caml_example*}
type c' = <m : int>;;
\end{caml_example*}
However, the abbreviation "#c'" cannot be defined directly in a similar way.
It can only be defined by a class or a class-type definition.
This is because a "#"-abbreviation carries an implicit anonymous
variable ".." that cannot be explicitly named.
The closer you get to it is:
\begin{caml_example*}
type 'a c'_class = 'a constraint 'a = < m : int; .. >;;
\end{caml_example*}
with an extra type variable capturing the open object type.

\section{Functional objects}
\pdfsection{Functional objects}
\label{ss:functional-objects}

It is possible to write a version of class "point" without assignments
on the instance variables. The override construct "{< ... >}" returns a copy of
``self'' (that is, the current object), possibly changing the value of
some instance variables.
\begin{caml_example}
class functional_point y =
  object
    val x = y
    method get_x = x
    method move d = {< x = x + d >}
  end;;
let p = new functional_point 7;;
p#get_x;;
(p#move 3)#get_x;;
p#get_x;;
\end{caml_example}
Note that the type abbreviation "functional_point" is recursive, which can
be seen in the class type of "functional_point": the type of self is "'a"
and "'a" appears inside the type of the method "move".

The above definition of "functional_point" is not equivalent
to the following:
\begin{caml_example}
class bad_functional_point y =
  object
    val x = y
    method get_x = x
    method move d = new bad_functional_point (x+d)
  end;;
\end{caml_example}
While objects of either class will behave the same, objects of their
subclasses will be different. In a subclass of "bad_functional_point",
the method "move" will
keep returning an object of the parent class.  On the contrary, in a
subclass of "functional_point", the method "move" will return an
object of the subclass.

Functional update is often used in conjunction with binary methods
as illustrated in section \ref{module:string}.

\section{Cloning objects}
\pdfsection{Cloning objects}
\label{ss:cloning-objects}

Objects can also be cloned, whether they are functional or imperative.
The library function "Oo.copy" makes a shallow copy of an object. That is,
it returns a new object that has the same methods and instance
variables as its argument. The
instance variables are copied but their contents are shared.
Assigning a new value to an instance variable of the copy (using a method
call) will not affect instance variables of the original, and conversely.
A deeper assignment (for example if the instance variable is a reference cell)
will of course affect both the original and the copy.

The type of "Oo.copy" is the following:
\begin{caml_example}
Oo.copy;;
\end{caml_example}
The keyword "as" in that type binds the type variable "'a" to
the object type "< .. >".  Therefore, "Oo.copy" takes an object with
any methods (represented by the ellipsis), and returns an object of
the same type. The type of "Oo.copy" is different from type "< .. > ->
< .. >" as each ellipsis represents a different set of methods.
Ellipsis actually behaves as a type variable.
\begin{caml_example}
let p = new point 5;;
let q = Oo.copy p;;
q#move 7; (p#get_x, q#get_x);;
\end{caml_example}
In fact, "Oo.copy p" will behave as "p#copy" assuming that a public
method "copy" with body "{< >}" has been defined in the class of "p".

Objects can be compared using the generic comparison functions "=" and "<>".
Two objects are equal if and only if they are physically equal. In
particular, an object and its copy are not equal.
\begin{caml_example}
let q = Oo.copy p;;
p = q, p = p;;
\end{caml_example}
Other generic comparisons such as ("<", "<=", ...) can also be used on
objects.  The
relation "<" defines an unspecified but strict ordering on objects.  The
ordering relationship between two objects is fixed once for all after the
two objects have been created and it is not affected by mutation of fields.

Cloning and override have a non empty intersection.
They are interchangeable when used within an object and without
overriding any field:
\begin{caml_example}
class copy =
  object
    method copy = {< >}
  end;;
class copy =
  object (self)
    method copy = Oo.copy self
  end;;
\end{caml_example}
Only the override can be used to actually override fields, and
only the "Oo.copy" primitive can be used externally.

Cloning can also be used to provide facilities for saving and
restoring the state of objects.
\begin{caml_example}
class backup =
  object (self : 'mytype)
    val mutable copy = None
    method save = copy <- Some {< copy = None >}
    method restore = match copy with Some x -> x | None -> self
  end;;
\end{caml_example}
The above definition will only backup one level.
The backup facility can be added to any class by using multiple inheritance.
\begin{caml_example}
class ['a] backup_ref x = object inherit ['a] oref x inherit backup end;;
let rec get p n = if n = 0 then p # get else get (p # restore) (n-1);;
let p = new backup_ref 0  in
p # save; p # set 1; p # save; p # set 2;
[get p 0; get p 1; get p 2; get p 3; get p 4];;
\end{caml_example}
We can define a variant of backup that retains all copies. (We also
add a method "clear" to manually erase all copies.)
\begin{caml_example}
class backup =
  object (self : 'mytype)
    val mutable copy = None
    method save = copy <- Some {< >}
    method restore = match copy with Some x -> x | None -> self
    method clear = copy <- None
  end;;
\end{caml_example}
\begin{caml_example}
class ['a] backup_ref x = object inherit ['a] oref x inherit backup end;;
let p = new backup_ref 0  in
p # save; p # set 1; p # save; p # set 2;
[get p 0; get p 1; get p 2; get p 3; get p 4];;
\end{caml_example}



\section{Recursive classes}
\pdfsection{Recursive classes}
\label{ss:recursive-classes}

Recursive classes can be used to define objects whose types are
mutually recursive.
\begin{caml_example}
class window =
  object
    val mutable top_widget = (None : widget option)
    method top_widget = top_widget
  end
and widget (w : window) =
  object
    val window = w
    method window = window
  end;;
\end{caml_example}
Although their types are mutually recursive, the classes "widget" and
"window" are themselves independent.


\section{Binary methods}
\pdfsection{Binary methods}
\label{ss:binary-methods}

A binary method is a method which takes an argument of the same type
as self. The class "comparable" below is a template for classes with a
binary method "leq" of type "'a -> bool" where the type variable "'a"
is bound to the type of self. Therefore, "#comparable" expands to "<
leq : 'a -> bool; .. > as 'a".  We see here that the binder "as" also
allows writing recursive types.
\begin{caml_example}
class virtual comparable =
  object (_ : 'a)
    method virtual leq : 'a -> bool
  end;;
\end{caml_example}
We then define a subclass "money" of "comparable". The class "money"
simply wraps floats as comparable objects. We will extend it below with
more operations. We have to use a type constraint on the class parameter "x"
because the primitive "<=" is a polymorphic function in
OCaml.  The "inherit" clause ensures that the type of objects
of this class is an instance of "#comparable".
\begin{caml_example}
class money (x : float) =
  object
    inherit comparable
    val repr = x
    method value = repr
    method leq p = repr <= p#value
  end;;
\end{caml_example}
% not explained: mutability can be hidden
Note that the type "money" is not a subtype of type
"comparable", as the self type appears in contravariant position
in the type of method "leq".
Indeed, an object "m" of class "money" has a method "leq"
that expects an argument of type "money" since it accesses
its "value" method.  Considering "m" of type "comparable" would allow a
call to method "leq" on "m" with an argument that does not have a method
"value", which would be an error.

Similarly, the type "money2" below is not a subtype of type "money".
\begin{caml_example}
class money2 x =
  object
    inherit money x
    method times k = {< repr = k *. repr >}
  end;;
\end{caml_example}
It is however possible to define functions that manipulate objects of
type either "money" or "money2": the function "min"
will return the minimum of any two objects whose type unifies with
"#comparable". The type of "min" is not the same as "#comparable ->
#comparable -> #comparable", as the abbreviation "#comparable" hides a
type variable (an ellipsis). Each occurrence of this abbreviation
generates a new variable.
\begin{caml_example}
let min (x : #comparable) y =
  if x#leq y then x else y;;
\end{caml_example}
This function can be applied to objects of type "money"
or "money2".
\begin{caml_example}
(min (new money  1.3) (new money 3.1))#value;;
(min (new money2 5.0) (new money2 3.14))#value;;
\end{caml_example}

More examples of binary methods can be found in sections
\ref{module:string} and \ref{module:set}.

Note the use of override for method "times".
Writing  "new money2 (k *. repr)" instead of  "{< repr = k *. repr >}"
would not behave well with inheritance: in a subclass "money3" of "money2"
the "times" method would return an object of class "money2" but not of class
"money3" as would be expected.

The class "money" could naturally carry another binary method. Here is a
direct definition:
\begin{caml_example}
class money x =
  object (self : 'a)
    val repr = x
    method value = repr
    method print = print_float repr
    method times k = {< repr = k *. x >}
    method leq (p : 'a) = repr <= p#value
    method plus (p : 'a) = {< repr = x +. p#value >}
  end;;
\end{caml_example}

\section{Friends}
\pdfsection{Friends}
\label{ss:friends}

The above class "money" reveals a problem that often occurs with binary
methods.  In order to interact with other objects of the same class, the
representation of "money" objects must be revealed, using a method such as
"value". If we remove all binary methods (here "plus" and "leq"),
the representation can easily be hidden inside objects by removing the method
"value" as well. However, this is not possible as soon as some binary
method requires access to the representation of objects of the same
class (other than self).
\begin{caml_example}
class safe_money x =
  object (self : 'a)
    val repr = x
    method print = print_float repr
    method times k = {< repr = k *. x >}
  end;;
\end{caml_example}
Here, the representation of the object is known only to a particular object.
To make it available to other objects of the same class, we are forced to
make it available to the whole world. However we can easily restrict the
visibility of the representation using the module system.
\begin{caml_example*}
module type MONEY =
  sig
    type t
    class c : float ->
      object ('a)
        val repr : t
        method value : t
        method print : unit
        method times : float -> 'a
        method leq : 'a -> bool
        method plus : 'a -> 'a
      end
  end;;
module Euro : MONEY =
  struct
    type t = float
    class c x =
      object (self : 'a)
        val repr = x
        method value = repr
        method print = print_float repr
        method times k = {< repr = k *. x >}
        method leq (p : 'a) = repr <= p#value
        method plus (p : 'a) = {< repr = x +. p#value >}
      end
  end;;
\end{caml_example*}
Another example of friend functions may be found in section
\ref{module:set}.  These examples occur when a group of objects (here
objects of the same class) and functions should see each others internal
representation, while their representation should be hidden from the
outside. The solution is always to define all friends in the same module,
give access to the representation and use a signature constraint to make the
representation abstract outside the module.



% LocalWords:  typecheck monomorphic uncaptured Subtyping subtyping leq repr Oo
% LocalWords:  val sig bool Euro struct OCaml Vouillon Didier int ref incr init
% LocalWords:  succ mytype rec

