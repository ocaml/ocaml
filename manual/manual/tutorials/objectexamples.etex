\chapter{Objects in Caml} \label{c:objectexamples}

This chapter gives an overview of the object-oriented features of
Objective Caml.
%% Some commented examples introduces progressively
%% most of its features.

\subsection*{Classes and objects}

The class "point" has one instance variable "x" and two methods
"get_x" and "move". The initial value of the instance variable is
given here by the class parameter "x_init".  The variable "x" is
declared mutable, so the method "move" can change its value.
\begin{caml_example} 
class point x_init =
  val mutable x = x_init
  method get_x = x
  method move d = x <- x + d
end;;
\end{caml_example}

We now create a new point "p", giving the initialization argument~"7". 
\begin{caml_example}
let p = new point 7;;
\end{caml_example}
Note that the type of "p" is "point". This is an
abbreviation automatically defined by the class definition above. It
stands for the object type "< get_x : int; move : int -> unit>",
listing the methods of class "point" along with their types.

Let us apply some methods to "p":
\begin{caml_example}
p#get_x;;
p#move 3;;
p#get_x;;
\end{caml_example}

The library function "Oo.copy" copies an object. Its type is
"< .. > as 'a -> 'a". The keyword "as" in that type
binds the type variable "'a" to the object type "< .. >".
"Oo.copy" therefore takes an object with any methods (represented by
the ellipsis), and returns an object of the same type. The type of
"Oo.copy" is different from type "< .. > -> < .. >" as each ellipsis
represents a different set of methods. Ellipsis actually behaves as a
type variable.
\begin{caml_example}
let q = Oo.copy p;;
q#move 7; (p#get_x, q#get_x);;
\end{caml_example}

\subsection*{Inheritance}

We now define a new class "colored_point". This class inherits from
class "point". So, it has all the instance variable and all the
methods of "point", plus a  new instance variable "c" and a new method
"color".
\begin{caml_example}
class colored_point x (c : string) =
  inherit point x
  val c = c
  method color = c
end;;
let p' = new colored_point 5 "red";;
p'#get_x, p'#color;;
\end{caml_example}

A point and a colored point have incompatible types: a point has no
method "color". However, 
the function "get_x" below is a generic function applying method
"get_x" to any object "p" which has this method (and
possibly some others, which are represented by an ellipsis in the
type). Thus it applies both to points and colored points. 
\begin{caml_example}
let get_succ_x p = p#get_x + 1;;
get_succ_x p + get_succ_x p';;
\end{caml_example}
Methods needs not be declared previously, as shown by the example:
\begin{caml_example}
let set_x p = p#set_x;;
let incr p = set_x p (get_succ_x p);;
\end{caml_example}


\subsection*{Parameterized classes}

Reference cells can also be implemented as objects:
\begin{caml_example}
class ref x_init = 
  val mutable x = x_init
  method get = x
  method set y = x <- y
end;;
\end{caml_example}
The reason why this definition does not typecheck is that at least one
of the methods has a polymorphic type (here, the type of the value
stored in the reference cell), thus the class should be parametric.  A
monomorphic instance of the class could be defined by:
\begin{caml_example}
class ref (x_init:int) = 
  val mutable x = x_init
  method get = x
  method set y = x <- y
end;;
\end{caml_example}
A class for polymorphic references must  explicitly list the
type parameters in its declaration.  The type parameters must also be
bound somewhere in the class body by a type constraint. 
\begin{caml_example}
class 'a ref x_init = 
  val mutable x = (x_init : 'a)
  method get = x
  method set y = x <- y
end;;
let r = new ref 1 in r#set 2; (r#get);;
\end{caml_example}
The type parameter in the declaration may actually be constrained in the
body of the class definition. In the class type, the actual value of
the type parameter is displayed in the "constraint" clause. 
\begin{caml_example}
class 'a ref (x_init:'a) = 
  val mutable x = x_init + 1
  method get = x
  method set y = x <- y
end;;
\end{caml_example}

Let us consider a more realistic example.  We put an additional type
constraint in method "move", since no free variables must remain uncaptured
by a type parameter.
\begin{caml_example}
class 'a circle (c : 'a) =
  val mutable center = c
  method center = center
  method set_center c = center <- c
  method move = (center#move : int -> unit)
end;;
\end{caml_example}

An alternate definition of "circle", using a "constraint" clause in
the class definition, is shown below. The type "#point" used below in
the "constraint" clause is an abbreviation produced by the definition
of class "point". This abbreviation unifies with the type of any
object belonging to a subclass of class "point". It actually expands to
"< get_x : int; move : int -> unit; .. >". This leads to the following
alternate definition of "circle", which has slightly stronger
constraints on its argument, as we now expect "center" to have a
method "get_x".
\begin{caml_example}
class 'a circle (c : 'a) =
  constraint 'a = #point
  val mutable center = c
  method center = center
  method set_center c = center <- c
  method move = center#move
end;;
\end{caml_example}

The class "colored_circle" is a specialized version of class
"circle" which requires the type of the center to unify with
"#colored_point", and adds a method "color".
\begin{caml_example}
class 'a colored_circle c =
  constraint 'a = #colored_point
  inherit ('a) circle c
  method color = center#color
end;;
\end{caml_example}


\subsection*{Self reference}

A method can also send messages to the object that invoked the method. 
For that, self must be explicitly bound, 
here to the variable "s".
\begin{caml_example}
class printable_point y as s =
  inherit point y
  method print = print_int s#get_x
end;;
let p = new printable_point 7;;
p#print;;
\end{caml_example}
The variable "s" is bound at the invocation of a method. In particular, if
the class "printable_point" is inherited, the variable "s" will correctly 
be bound to an object of the subclass. 



\subsection*{Multiple inheritance}

Multiple inheritance is allowed. Only the last definition of a method
(or  of an instance variable) is kept.
But previous definitions of a method can be reused by binding the
related ancestor. Here, "super" is bound to the ancestor
"printable_point". The name "super" is not actually a variable and
can only be used to select a method as in "super#print".
\begin{caml_example}
class printable_colored_point y c as self =
  inherit colored_point y c
  inherit printable_point y as super
  method print =
    print_string "(";
    super#print;
    print_string ", ";
    print_string (self#color);
    print_string ")"
end;;
let p' = new printable_colored_point 7 "red";;
p'#print;;
\end{caml_example}

\subsection*{Non-mutable objects}

It is possible to write a version of class "point" without assignments
on the instance variables. The construct "{< ... >}" returns a copy of
``self'' (that is, the current object), possibly changing the value of
some instance variables.
\begin{caml_example}
class functional_point y =
  val x = y
  method get_x = x
  method move d = {< x = x + d >}
end;;
let p = new functional_point 7;;
p#get_x;;
(p#move 3)#get_x;;
p#get_x;;
\end{caml_example}
Note that the type abbreviation "functional_point" is recursive, which can
be seen in the class type of "functional_point": the type of self to "'a"
and "'a" appears inside the type of the "move" method.

\subsection*{Virtual methods}

The class "comparable" below is a template for classes with a binary
method "leq" of type "'a -> bool" where the type variable
"'a" is bound to the type of self. Since this class has a method declared
but not defined, it must be flagged virtual and cannot be instantiated
(that is, no object of this class can be created). It still
defines abbreviations. In particular,
"#comparable" expands to "< leq : 'a -> bool; .. > as 'a".
We see here that the binder "as" also allows to write recursive
types.
\begin{caml_example}
class virtual comparable () : 'a =
  virtual leq : 'a -> bool
end;;
\end{caml_example}

We then define a subclass of "comparable", which wraps integers as
comparable objects. There is a type constraint on the class parameter "x"
as the primitive "<=" is a polymorphic comparison function in
Objective Caml.  The "inherit" clause ensures that the type of objects
of this class is an instance of "#comparable".
\begin{caml_example}
class int_comparable (x : int) =
  inherit comparable ()
  val x = x
  method x = x
  method leq p = x <= p#x
end;;
\end{caml_example}

Objects of class "int_comparable2" below can also modify the integer
they hold. The status of instance variable "x" is changed. It is
now mutable and private; that is, subclasses cannot access it (it does
no longer appear in the class type). Note that the type
"int_comparable2" is not a subtype of type "int_comparable",
as the self type appears in contravariant position in the type of method
"leq".
\begin{caml_example}
class int_comparable2 x =
  inherit int_comparable x
  val private mutable x
  method set_x y = x <- y
end;;
\end{caml_example}

The function "min" will return the minimum of any two objects
whose type unify with "#comparable". The type of "min" is
not the same as "#comparable -> #comparable -> #comparable", as
the abbreviation "#comparable" hides a type variable (an
ellipsis). Each occurrence of this abbreviation generates a new
variable.
\begin{caml_example}
let min (x : #comparable) y =
  if x#leq y then x else y;;
\end{caml_example}
This function can be applied to objects of type "int_comparable"
or "int_comparable2".
\begin{caml_example}
(min (new int_comparable  7) (new int_comparable 11))#x;;
(min (new int_comparable2 5) (new int_comparable2 3))#x;;
\end{caml_example}


\subsection*{Using coercions}

Subtyping in ocaml is never implicit.  There are however too ways of getting
subtyping.  The most general contruction is fully explicit: both the domain
and the co-domain of the type coercion must be given.

We have seen that point and colored points are incompatible types.  For
instanace, the point "p" and the colored point "p'" cannot be put in the same
list However, a colored point can be coerced to a point, hiding its "color"
method:
\begin{caml_example}
let colored_point_to_point cp = (cp : colored_point :> point);;
\end{caml_example}
Thus,  "p" and "p'" can be put in the same list as follows
in the same list, one needs to coerce "p'" to the type of points,
\begin{caml_example}
let p = new point 3 and q = new colored_point 4 "blue";;
let l = [p; (colored_point_to_point q)];;
\end{caml_example}
An object of type $t_1$ can be seen as an objetc of type $t_2$ 
only if $t_1$ is a subtype of $t_2$. For instance, the point "p" cannot be
seen as a colored point. 
\begin{caml_example}
(p : point :> colored_point);;
\end{caml_example}
Indeed, backward coercions are unsafe, and should be combined with a typecase,
possible raising a runtime error.  However, there is not such operation
available in the language. 

Be aware that subtyping and inheritance are not related. 
Inheritance is a syntactic relation between classed  while subtyping is a
semantic relation between types. 
For instance, the class colored points could have been defined directly
without inheriting from the class of points; still, colored points would be
subtypes of points. Conversely, the class "int_comparable" inherits from
class "comparable", but type "int_comparable" is not a subtype of
"comparable". 
\begin{caml_example}
function x -> (x : int_comparable :> comparable);;
\end{caml_example}
% XXX the message above is too verbose ...
Indeed, an object "p" of class "int_comparable" has a method "leq" that expects
an argument of type "int_comparable" since it accesses its "x" method. 
Considering "p" of type "comparable" would allow call method "leq" on "p"
with an argument that does not have a method "x", which would be an error.

The domain of a coercion may be ommitted. For instance, one can define:
\begin{caml_example}
let to_point cp = (cp :> point);;
\end{caml_example}
In this case, the function "colored_point_to_point" is an instance of the 
function "point". This is not the general case however, and the fully
explicit coercion  is more precise and thus unavoidable in some cases. 
Here is an example:
\begin{caml_example}
class virtual c () = virtual m : c end;;
class c' () as self =
  inherit c ()
  method m = (self :> c)
  method m' = 1
end;;
\end{caml_example}
The coercion to class "c" can be seen here:
\begin{caml_example}
function x -> (x :> c);;
\end{caml_example}
Note that this function does not have type "<m : c;..> -> c" as may be
expected.  This produces the type contradiction for type "c'".  As class
"c'" inherits from class "c", it has a method "m" of type "c". As the
expression "(self :> c)" is used, the type of "self" must be unified with
the domain of the coercion above; that is "self" must have a method "m" of
type "self", and so "c'" must have a method "m" of type "c'". However, "c'"
and "c" are different as "c" does not contain a method "m'".

The desired function of type "<m : c;..> -> c" is given by using a fully
explicit coercion:
\begin{caml_example}
function x -> (x : #c :> c);;
\end{caml_example}
Thus one can define class c' as follows:
\begin{caml_example}
class c' () as self =
  inherit c ()
  method m = (self : #c :> c)
  method m' = 1
end;;
\end{caml_example}
An alternative is to define class "c" as follows (of course
this definition is not equivalent to the previous one):
\begin{caml_example}
class virtual c () : 'a = virtual m : 'a end;;
\end{caml_example}
Then, a coercion operator is not even required.
\begin{caml_example}
class c' () as self =
  method m = self
  method m' = 1
end;;
\end{caml_example}
Moreover, the simple coercion operator "(e :> t)" can be used to
coerce an object of type "c'" to type "c". It is actually defined so
as to work fine with classes returning "self" without coercion.
\begin{caml_example}
(new c' () :> c);;
\end{caml_example}

Another common problem may occur when one tries to define a coercion to a
class "c" inside the definition of class "c". The problem is due to the type
abbreviation not being completely defined, and so its subtypes are not
clearly known.  Thus the coercion "(_ : #c :> c)" is the identify function,
as in
\begin{caml_example}
function x -> (x :> 'a);;
\end{caml_example}
Moreover, if the coercion is applied to "self", as in the following example,
then the type of "self" is unified with the closed type of "c". 
This requires the class to be closed:
\begin{caml_example}
class c () as self = method m = (self : #c :> c) end;;
\end{caml_example}
Although declaring the class as "closed" will typecheck, this is not usually
what is desired
\begin{caml_example}
class closed c () as self = method m = (self : #c :> c) end;;
\end{caml_example}
This problem can be avoided by first defining the abbreviation
\begin{caml_example}
type c = <m : c>;;
class c' () as self = method m = (self : #c :> c) end;;
\end{caml_example}
The abbreviation could also have been defined using a virtual class:
\begin{caml_example}
class virtual c () = virtual m : c end;;
\end{caml_example}
Then, the class "c'" may be declared to inherit from the virtual class "c", 
which simultaneously enforces all methods of "c'" to have the same type as
the methods of "c".
\begin{caml_example}
class c' () as self = inherit c () method m = (self : #c :> c) end;;
\end{caml_example}





\subsection*{Recursive classes}

% Recusive classes are useless

% je te laisse completer l'exemple des fenetre et boutons, 

% car je n'arrive plus à reconstruire un exemple interessant
% que l'on ne puisse pas écrire sans les classes recursives...
% (on peut toujours définir les types objets récursivement)


\subsection*{Class interfaces}

Class interfaces are inferred from class definitions. 
They may also be defined directly in interfaces of modules. 
For instance the following is 
the interface of a module defining class point. 
\begin{caml_example}
module type POINT = sig 
  class point (int) =
    val mutable x : int
    method get_x : int
    method move : int -> unit
 end 
end;;
module Point : POINT = struct 
  class point x = inherit point x end
end;;
\end{caml_example}
It is sometime necessay to restrict the interface of classes. 
Instance variables can be hiden explicitly in a subclass definition:
\begin{caml_example}
class point x =
  inherit Point.point x
  val private mutable x
end;;
\end{caml_example}
This can also be done implicitly by signature matching:
\begin{caml_example}
module type ABSPOINT = sig 
  class point (int) =
    method get_x : int
    method move : int -> unit
 end 
end;;
module Abspoint : ABSPOINT = Point;;
\end{caml_example}
However, in the current implementation, 
methods cannot be hidden implictlty nor explicity.


\subsection*{Simple modules as classes}

In Objective Caml one often has a choice between using modules or classes. 

% XXX some motivation

Indeed, there are situations when the two approches are quite similar. 

% XXX stack example

However, the nice correspondance between the implementations of stacks as 
modules or classes is a very particular case. 

% XXX Maps

% problem 

% solution



% XXX Sets


% problem 

% solution





